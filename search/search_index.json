{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#what-is-decompose","title":"What is Decompose?","text":"<p>Decompose is a Kotlin Multiplatform library for breaking down your code into lifecycle-aware business logic components (aka BLoC), with routing functionality and pluggable UI (Compose, Android Views, SwiftUI, Kotlin/React, etc.).</p>"},{"location":"#supported-targets","title":"Supported targets","text":"<ul> <li><code>android</code>,</li> <li><code>jvm</code></li> <li><code>js</code> (both <code>IR</code> and <code>Legacy</code> modes)</li> <li><code>iosX64</code>, <code>iosArm64</code>, <code>iosSimulatorArm64</code></li> <li><code>tvosArm64</code>, <code>tvosX64</code>, <code>tvosSimulatorArm64</code></li> <li><code>watchosArm32</code>, <code>watchosArm64</code>, <code>watchosX64</code>, <code>watchosSimulatorArm64</code></li> <li><code>macosX64</code>, <code>macosArm64</code></li> </ul>"},{"location":"#why-decompose","title":"Why Decompose?","text":"<ul> <li>Decompose draws clear boundaries between UI and non-UI code, which gives the following benefits:<ul> <li>Better separation of concerns</li> <li>Pluggable platform-specific UI (Compose, SwiftUI, Kotlin/React, etc.)</li> <li>Business logic code is testable with pure multiplatform unit tests</li> </ul> </li> <li>Proper dependency injection (DI) and inversion of control (IoC) via constructor, including but not limited to type-safe arguments.</li> <li>Shared navigation logic</li> <li>Lifecycle-aware components</li> <li>Components in the back stack are not destroyed, they continue working in background without UI</li> <li>Components and UI state preservation (mostly useful in Android)</li> <li>Instances retaining (aka ViewModels) over configuration changes (mostly useful in Android)</li> </ul>"},{"location":"#decompose-is-a-library","title":"Decompose is a library","text":"<p>Decompose is a library that can be used as a framework. In its core, Decompose just manipulates instances of ComponentContext with strict parent-child relationship, which is also called \"navigation\". The possibility of creating custom implementations of the <code>ComponentContext</code> interface allows adding custom properties and functions, as well as storing additional data in each instance of <code>ComponentContext</code>. This makes it a very powerful tool with various use cases.</p> <p>The \"component\" term is just one of the possible usages, the recommended one. The Decompose-Router library is a great example of leveraging Decompose to create a custom navigation solution with a completely different API.</p>"},{"location":"community/","title":"Community","text":"<p>This page contains links to various useful projects related to Decompose and maintained by the community.</p>"},{"location":"community/#decompose-router","title":"Decompose-Router","text":"<p>A Compose-multiplatform navigation library that leverage Decompose to create an API inspired by Conductor.</p> <p>Tip</p> <p>Decompose-Router is a lightweight library based on Decompose, it can be especially useful if you find Decompose cumbersome or difficult to learn.</p> <p>Link: github.com/xxfast/Decompose-Router</p> <p>Author: @xxfast</p>"},{"location":"community/#mvikotlin-decompose-template-idea-plugin","title":"MVIKotlin Decompose Template (IDEA Plugin)","text":"<p>Decompose and MVIKotlin plugin template, which will help you to create new components.</p> <p>Link: plugins.jetbrains.com/plugin/22852-mvikotlin-decompose-template</p> <p>Source code: github.com/makeevrserg/MVIKotlin-Decompose-Plugin</p> <p>Author: @makeevrserg</p>"},{"location":"community/#decompose-with-compose-lazylist","title":"Decompose with Compose LazyList","text":"<p>A project that shows an example of implementing your <code>children</code> extension to use Decompose components in Compose LazyList</p> <p>Source code: github.com/EvgenyMeltsaykin/Decompose-LazyList</p> <p>Author: @EvgenyMeltsaykin</p>"},{"location":"community/#decompose-detekt-rules","title":"Decompose Detekt Rules","text":"<p>A set of custom detekt rules that help you avoid critical mistakes when working with Decompose.</p> <p>Link: github.com/AJIEKCX/decompose-detekt-rules</p> <p>Author: @AJIEKCX</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#why-lifecycle-callbacks-are-not-called-on-ios-or-any-other-non-android-platform","title":"Why lifecycle callbacks are not called on iOS (or any other non-Android platform)?","text":"<p>On non-Android platforms the <code>Lifecycle</code> should usually be controlled manually. This can be done by creating an instance of <code>LifecycleRegistry</code>, passing it to <code>DefaultComponentContext</code>, and then controlling the <code>LifecycleRegistry</code> based on platform-specific lifecycle events. Please refer to the sample project to learn about platform integrations.</p> <p>However, there are convenient APIs for some platforms.</p>"},{"location":"faq/#lifecycle-on-ios","title":"Lifecycle on iOS","text":"<p>If the root component lives in the application scope (i.e. Decompose is used in the entire application, not partially in one screen), then <code>ApplicationLifecycle</code> API from Essenty can be used. <code>ApplicationLifecycle</code> can be destroyed manually if needed, e.g. when the root component is created in a <code>UIViewController</code> and the screen is closed.</p>"},{"location":"faq/#lifecycle-on-compose-for-desktop-jvm","title":"Lifecycle on Compose for Desktop (JVM)","text":"<p>There is the <code>LifecycleController</code> API available on Compose for Desktop.</p>"},{"location":"faq/#error-another-supplier-is-already-registered-with-the-key","title":"Error \"Another supplier is already registered with the key\"","text":"<p>This exception is thrown by <code>StateKeeper</code> when its <code>register</code> method is called second time with the same key.</p> <ul> <li>If you are using Compose, make sure that you create the root component context and component outside Compose. See the docs. Otherwise, a second instance can be created if the root Composable function re-composes.</li> <li>Don't use <code>get() =</code> for navigation properties (such as <code>val stack: Value&lt;ChildStack&lt;...&gt;&gt;</code>), just assign the value to the property.     <pre><code>- val stack: Value&lt;ChildStack&lt;...&gt;&gt; get() = childStack(...)\n+ val stack: Value&lt;ChildStack&lt;...&gt;&gt; = childStack(...)\n</code></pre></li> <li>If you are using more than one <code>childStack</code> in one component (or more than one navigation model of the same kind in one component), then please supply the <code>key</code> argument for every such function.     <pre><code>val stack1: Value&lt;ChildStack&lt;...&gt;&gt; = childStack(key = \"stack1\", ...)\nval stack2: Value&lt;ChildStack&lt;...&gt;&gt; = childStack(key = \"stack2\", ...)\n</code></pre></li> </ul>"},{"location":"faq/#error-configurations-must-be-unique","title":"Error \"Configurations must be unique\"","text":"<p>This exception is thrown when duplicated component configurations are detected by a navigation model (e.g. Child Stack). Duplicates are checked according to the <code>equals</code> method, which all configurations must be properly implementing. See the docs for more information.</p> <ul> <li>Prefer <code>pushNew</code> function instead of <code>push</code> when showing a component on a button click, it will properly handle accidental double clicks.</li> <li>Prefer <code>pushToFront</code> to prevent duplicated components with the same data (configurations) in the stack.</li> </ul>"},{"location":"faq/#the-experimental-duplicate-configurations-mode","title":"The experimental Duplicate Configurations mode","text":"<p>You can also try enabling the experimental Duplicate Configurations mode using the following flag:</p> <pre><code>DecomposeExperimentFlags.duplicateConfigurationsEnabled = true\n</code></pre> <p>This will allow having duplicate configurations in all navigation models. Please keep in mind that this feature is experimental.</p>"},{"location":"samples/","title":"Samples","text":""},{"location":"samples/#multi-feature-sample-app","title":"Multi-Feature Sample App","text":"<p>This sample demonstrates the following features:</p> <ul> <li>Nested reusable components</li> <li>Bottom navigation</li> <li>Nested navigation</li> <li>Various navigation models: Child Stack, Child Slot, Child Pages, Child Items, Generic Navigation</li> <li>State preservation (using <code>StateKeeper</code>)</li> <li>Retaining instances (using <code>InstanceKeeper</code>)</li> <li>Pluggable UI (Android Views, Compose, SwiftUI, Kotlin/React)</li> <li>Play Feature Delivery for Android</li> <li>Tests, including Compose UI tests</li> </ul> <p>Please note that Gradle files included in this sample project are not supposed to be used as a reference. They share the configuration with the reset of the library, which simplifies the maintenance a lot. Please refer to the KMP documentation for information on configuring a KMP project. You can also check other sample projects described below.</p> <p>Content:</p> <ul> <li>shared - this is a shared module that contains the Root component, as well as all child components with the following hierarchy:<ul> <li>Tabs - a fullscreen component that displays the bottom navigation bar and the currently selected tab.<ul> <li>Menu - the Menu tab, contains <code>MenuComponent</code> with buttons leading to other fullscreen components.</li> <li>Counters - the Counters tab, contains a stack of <code>CounterComponent</code>.<ul> <li>Counter - contains <code>CounterComponent</code>, it just increments the counter every 250 ms. It starts counting once created and stops when destroyed. So <code>CounterComponent</code> continues counting while in the back stack, unless recreated. It uses the <code>InstanceKeeper</code>, so counting continues after Android configuration changes. The <code>StateKeeper</code> is used to preserve the state when the process is recreated on Android.</li> </ul> </li> <li>Cards - the (draggable) Cards tab, contains a stack of <code>Card</code> components that can be dragged and thrown to the back of the stack. The top component is resumed and running, and components in the back stack are stopped. This sample demonstrates how the navigation can be controlled by gestures.<ul> <li>Card - contains <code>CardComponent</code> - a draggable card with some text information.</li> </ul> </li> <li>Multi Pane - the Multi-Pane tab, it displays <code>ArticleListComponent</code> and <code>ArticleDetailsComponent</code> components either in a stack (one on top of another) or side by side. Please note that this sample is for advanced single-pane/multi-pane navigation and layout, for generic master-detail navigation please refer to the Sample Todo List App described below.<ul> <li>ArticleListComponent - displays a random list of articles. Clicking on an item triggers the <code>ArticleDetails</code> component.</li> <li>ArticleDetailsComponent - displays the content of the selected article.</li> </ul> </li> </ul> </li> <li>Dynamic Features - the Dynamic Features fullscreen component, it demonstrates the usage of Play Feature Delivery on Android, while using classic integration on other platforms. There are two simple feature components - <code>Feature1</code> and <code>Feature2</code> - they are located in separate modules described below.<ul> <li>Dynamic Feature - a helper component responsible for loading dynamic feature components.</li> </ul> </li> <li>Custom Navigation - the Custom Navigation fullscreen component that demonstrates the usage of the Generic Navigation model.</li> <li>Pages - the Pages fullscreen component that demonstrates the usage of the Child Pages navigation model.</li> <li>Shared Transitions - the Shared Transitions fullscreen component that features the usage of the Compose shared transitions together with Decompose.<ul> <li>Gallery - the Gallery fullscreen component with a lazy grid of child <code>Thumbnail</code> components.</li> <li>Thumbnail - the Thumbnail component with an image, hosted in the <code>Gallery</code> component's lazy list.</li> <li>Photo - the Photo fullscreen component displaying an image selected in the <code>Gallery</code> component.</li> </ul> </li> </ul> </li> <li>compose - this module contains Compose UI.</li> <li>dynamic-features/api - this module contains only API for dynamic feature components.</li> <li>dynamic-features/compose-api - this module contains only Compose API for dynamic feature components.</li> <li>dynamic-features/feature1Impl - contains the implementation of <code>Feature1</code> dynamic feature component. On Android it depends on <code>android-app</code> module and is used via reflection. On all other targets, the <code>shared</code> module directly depends on this module and no reflection is used.</li> <li>dynamic-features/feature2Impl - contains the implementation of <code>Feature2</code> dynamic feature component. On Android it depends on <code>android-app</code> module and is used via reflection. On all other targets, the <code>shared</code> module directly depends on this module and no reflection is used.</li> <li>Android sample app</li> <li>Desktop sample app</li> <li>iOS sample app with SwiftUI</li> <li>iOS sample app with Compose</li> <li>Web (JS) sample app with Kotlin/React</li> <li>Web (JS) sample app with Compose</li> <li>Tests<ul> <li>RootComponentIntegrationTest - integration tests for <code>RootComponent</code>, including navigation tests.</li> <li>TabsComponentIntegrationTest - integration tests for <code>TabsComponent</code>, including navigation tests.</li> <li>CountersComponentIntegrationTest - integration tests for <code>CountersComponent</code>, including navigation tests.</li> <li>CounterComponentTest - unit tests for <code>CounterComponent</code>. Includes supplying test dependencies, tests for instance retaining and state preservation, etc.</li> <li>CounterContentTest - Compose UI tests for <code>CounterComponent</code>.</li> </ul> </li> </ul> <p>Warning</p> <p>The Multi-Pane sample is only for advanced single-pane/multi-pane navigation and layout. For generic master-detail navigation please refer to the Sample Todo List App described below.</p>"},{"location":"samples/#component-hierarchy","title":"Component Hierarchy","text":""},{"location":"samples/#fullscreen-navigation-screenshots","title":"Fullscreen Navigation Screenshots","text":""},{"location":"samples/#counters-screenshots","title":"Counters Screenshots","text":""},{"location":"samples/#swipeable-cards-screenshots","title":"Swipeable Cards Screenshots","text":""},{"location":"samples/#multi-pane-screenshots","title":"Multi-Pane Screenshots","text":""},{"location":"samples/#sample-todo-app","title":"Sample Todo App","text":"<p>Simple todo application with a list and detail page that shares UI between Android and desktop with Compose Multiplatform and SwiftUI for iOS. The following libraries are used in this sample: </p> <ul> <li>MVIKotlin - presentation and business logic</li> <li>Reaktive - background processing and data transformation</li> <li>SQLDelight - data storage</li> </ul> <p>TodoAppDecomposeMviKotlin</p> <p></p>"},{"location":"samples/#decompose-dagger-sample","title":"Decompose-Dagger Sample","text":"<p>A sample Android project demonstrating the use of Decompose library together with Dagger DI framework.</p> <p>decompose-dagger-sample</p>"},{"location":"samples/#sample-greetings-app","title":"Sample Greetings App","text":"<p>Sample Greetings Repository</p>"},{"location":"samples/#related-articles","title":"Related Articles","text":"<ul> <li>Decompose \u2014 experiments with Kotlin Multiplatform lifecycle-aware components and navigation</li> <li>Fully cross-platform Kotlin applications (almost)</li> <li> <p>A comprehensive thirty-line navigation for Jetpack/Multiplatform Compose - if you find Decompose verbose and would prefer something built on top of Compose.</p> </li> <li> <p>\"Component-based Approach\" series by Artur Artikov</p> <ul> <li>Part 1: Fighting Complexity in Android Applications</li> <li>Part 2: Implementing Screens with the Decompose Library</li> </ul> </li> </ul>"},{"location":"component/back-button/","title":"Back button handling","text":"<p>Some devices (e.g. Android) have hardware back buttons. A very common use case is to close the current screen, or the app if there is only one screen in the stack. Another possible use case is to show a confirmation dialog before closing the app.</p>"},{"location":"component/back-button/#navigation-with-back-button","title":"Navigation with back button","text":"<p>Most of the navigation models (such as Child Stack) can automatically navigate back when the back button is pressed. All you need to do is to supply the <code>handleBackButton = true</code> argument when you initialize a navigation model.</p> <p>Similarly, <code>Child Slot</code> can automatically dismiss the child component when the back button is pressed. See the Child Slot documentation page for more information.</p>"},{"location":"component/back-button/#manual-back-button-handling","title":"Manual back button handling","text":"<p>The back button can be handled manually using <code>BackHandler</code> (comes from Essenty library), which is provided by <code>ComponentContext</code>. The <code>decompose</code> module adds Essenty's <code>back-handler</code> module as <code>api</code> dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the <code>BackHandler</code> and <code>BackDispatcher</code>.</p>"},{"location":"component/back-button/#usage-example","title":"Usage example","text":"<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.backhandler.BackCallback\n\nclass SomeComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    private val backCallback = BackCallback { /* Handle the back button */ }\n\n    init {\n        backHandler.register(backCallback)\n    }\n\n    private fun updateBackCallback() {\n        // Set isEnabled to true if you want to override the back button\n        backCallback.isEnabled = true // or false\n    }\n}\n</code></pre>"},{"location":"component/back-button/#callback-order","title":"Callback order","text":"<p>By default, registered callbacks are checked in reverse order, the last registered enabled callback is called first. Various navigation models may also register back button callbacks, e.g. <code>Child Stack</code> uses <code>BackHandler</code> to automatically pop the stack on back button press. If you want your callback to be called first, make sure to register it as later as possible. Similarly, if you want your callback to be called last, make sure to register it as early as possible.</p> <p>It is also possible to specify a priority for your back callback.</p> <pre><code>// This will make sure your callback is always called first\nprivate val backCallback = BackCallback(priority = Int.MAX_VALUE) { ... }\n\n// This will make sure your callback is always called last\nprivate val backCallback = BackCallback(priority = Int.MIN_VALUE) { ... }\n</code></pre>"},{"location":"component/back-button/#predictive-back-gesture","title":"Predictive Back Gesture","text":"<p>Decompose experimentally supports the new Android Predictive Back Gesture, not only on Android. The UI part is covered by Compose extensions, please see the related docs.</p>"},{"location":"component/back-button/#back-button-handling-in-compose","title":"Back button handling in Compose","text":"<p>By default, Decompose doesn't propagate <code>LocalOnBackPressedDispatcherOwner</code> from Jetpack <code>activity-compose</code> library. Therefore, using <code>BackHandler {}</code> Composable API from <code>activity-compose</code> will register the callback in the root <code>OnBackPressedDispatcher</code>. This will cause the Composable handler to always intercept the back button, regardless of the component hierarchy.</p> <p>If you are using <code>BackHandler</code> from Jetpack <code>activity-compose</code> library, make sure that it's enabled only when needed. This can be done by supplying the <code>enabled</code> argument. See the official docs for more information.</p> <p>Another approach is to use the <code>BackHandler</code> provided by Essenty library and implemented for you by Decompose. Expose <code>BackHandler</code> from your component and register/unregister the callback in your Composable function.</p> The component interface<pre><code>import com.arkivanov.essenty.backhandler.BackHandlerOwner\n\ninterface SomeComponent : BackHandlerOwner {\n    // Omitted code\n}\n</code></pre> Implementing the component<pre><code>class DefaultSomeComponent(\n    componentContext: ComponentContext,\n) : ComponentContext by componentContext {\n    // No need to implement BackHandlerOwner interface, already implemented by ComponentContext\n}\n</code></pre> Custom BackHandler Composable API<pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.DisposableEffect\nimport androidx.compose.runtime.SideEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberUpdatedState\nimport com.arkivanov.essenty.backhandler.BackCallback\nimport com.arkivanov.essenty.backhandler.BackHandler\n\n@Composable\nfun BackHandler(backHandler: BackHandler, isEnabled: Boolean = true, onBack: () -&gt; Unit) {\n    val currentOnBack by rememberUpdatedState(onBack)\n\n    val callback =\n        remember {\n            BackCallback(isEnabled = isEnabled) {\n                currentOnBack()\n            }\n        }\n\n    SideEffect { callback.isEnabled = isEnabled }\n\n    DisposableEffect(backHandler) {\n        backHandler.register(callback)\n        onDispose { backHandler.unregister(callback) }\n    }\n}\n</code></pre> <p>Now we can use the newly created <code>BackHandler</code> Composable API similarly to the one provided by Jetpack.</p> <pre><code>import androidx.compose.runtime.Composable\n\n@Composable\nfun SomeContent(component: SomeComponent) {\n    BackHandler(backHandler = component.backHandler) {\n        // Handle the back button here\n    }\n}\n</code></pre>"},{"location":"component/back-button/#back-button-handling-in-compose-for-desktop","title":"Back button handling in Compose for Desktop","text":"<p>When using Compose for Desktop, it might be necessary to simulate back button navigation when the user presses a certain key (e.g. the Escape key). We can listen for unconsumed key events using <code>onKeyEvent</code> callback of the <code>Window {}</code> Composable function and call <code>BackDispatcher#back</code> when needed. </p> <pre><code>import androidx.compose.ui.input.key.Key\nimport androidx.compose.ui.input.key.KeyEventType\nimport androidx.compose.ui.input.key.key\nimport androidx.compose.ui.input.key.type\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\nimport com.arkivanov.decompose.DefaultComponentContext\nimport com.arkivanov.essenty.backhandler.BackDispatcher\nimport com.arkivanov.sample.shared.root.DefaultRootComponent\n\nfun main() {\n    val backDispatcher = BackDispatcher() // Create BackDispatcher\n\n    val root =\n        runOnUiThread {\n            DefaultRootComponent(\n                componentContext = DefaultComponentContext(\n                    lifecycle = ...,\n                    backHandler = backDispatcher, // Pass BackDispatcher to root ComponentContext\n                ),\n            )\n        }\n\n    application {\n        Window(\n            onCloseRequest = ::exitApplication,\n            onKeyEvent = { event -&gt;\n                if ((event.key == Key.Escape) &amp;&amp; (event.type == KeyEventType.KeyUp)) {\n                    backDispatcher.back() // Call BackDispatcher on Escape key up event\n                } else {\n                    false\n                }\n            },\n        ) {\n            ...\n        }\n    }\n}\n</code></pre>"},{"location":"component/child-components/","title":"Child components","text":"<p>Decompose provides ability to organize components as trees, so each parent component is only aware of its immediate children. Hence the name of the library - \"Decompose\". You decompose your project by multiple independent reusable components. When adding a subtree into another place (reusing), you only need to satisfy its top component's dependencies.</p> <p>There are two common ways to work with child components:</p> <ul> <li>Navigation - when you need to dynamically switch child components. Please head to   the Navigation documentation page for more information.</li> <li>Manually - when you need to add a permanent child component, or to manually control its <code>Lifecycle</code>.</li> </ul>"},{"location":"component/child-components/#adding-a-child-component-manually","title":"Adding a child component manually","text":"<p>A permanent child component should be always instantiated during the initialisation of the parent, and it is automatically destroyed at the end of the parent's lifecycle. It is possible to manually control the lifecycle of a permanent child component, e.g. resume it, pause or stop. But permanent child components must never be destroyed manually.</p> <p>Warning</p> <p>Every child component needs its own <code>ComponentContext</code>. Never pass parent's <code>ComponentContext</code> to children, always use either navigation or the <code>childContext(...)</code> function. There may be a runtime crash if the same component context is passed to multiple components and they use same keys for <code>StateKeeper</code>, <code>InstanceKeeper</code> or navigation.</p> <p>A child <code>ComponentContext</code> can be created using the following extension function:</p> <p><code>ComponentContext.childContext(key: String, lifecycle: Lifecycle? = null): ComponentContext</code></p> Example of a child component without lifecycle control<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.childContext\n\nclass SomeParent(componentContext: ComponentContext) : ComponentContext by componentContext {\n\n    val counter: Counter = Counter(childContext(key = \"Counter\"))\n}\n</code></pre> Example of a child component with lifecycle control<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.childContext\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\nimport com.arkivanov.essenty.lifecycle.resume\nimport com.arkivanov.essenty.lifecycle.stop\n\nclass SomeParent(componentContext: ComponentContext) : ComponentContext by componentContext {\n\n    // Never destroy the lifecycle of a permanent child component! \n    private val counterLifecycle = LifecycleRegistry()\n\n    val counter: Counter = Counter(childContext(key = \"Counter\", lifecycle = counterLifecycle))\n\n    private fun resumeCounter() {\n        counterLifecycle.resume()\n    }\n\n    private fun stopCounter() {\n        counterLifecycle.stop()\n    }\n}\n</code></pre>"},{"location":"component/custom-component-context/","title":"Custom <code>ComponentContext</code>","text":"<p>If you need <code>ComponentContext</code> to have extra functionality that is not already provided, it is possible to create a custom component context that could be decorated with the desired functionality of your choice. For instance, in some cases it might be useful to create a component context interface with additional properties required by most of the components.</p>"},{"location":"component/custom-component-context/#create-and-implement-custom-componentcontext","title":"Create and implement custom ComponentContext","text":"<p>To define a custom component context, create an interface that extends the <code>GenericComponentContext</code> interface, then implement it by delegating parts to the existing <code>ComponentContext</code>. Also, implement the <code>componentContextFactory</code> property to allow Decompose creating new instances of the custom component context type.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.ComponentContextFactory\nimport com.arkivanov.decompose.GenericComponentContext\nimport com.arkivanov.essenty.backhandler.BackHandlerOwner\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeperOwner\nimport com.arkivanov.essenty.lifecycle.LifecycleOwner\nimport com.arkivanov.essenty.statekeeper.StateKeeperOwner\n\ninterface AppComponentContext : GenericComponentContext&lt;AppComponentContext&gt; {\n\n    val logger: Logger // Additional property\n}\n\nclass DefaultAppComponentContext(\n    componentContext: ComponentContext,\n    override val logger: Logger,\n) : AppComponentContext,\n    LifecycleOwner by componentContext,\n    StateKeeperOwner by componentContext,\n    InstanceKeeperOwner by componentContext,\n    BackHandlerOwner by componentContext {\n\n    override val componentContextFactory: ComponentContextFactory&lt;AppComponentContext&gt; =\n        ComponentContextFactory { lifecycle, stateKeeper, instanceKeeper, backHandler -&gt;\n            val ctx = componentContext.componentContextFactory(lifecycle, stateKeeper, instanceKeeper, backHandler)\n            DefaultAppComponentContext(ctx, logger)\n        }\n}\n</code></pre>"},{"location":"component/instance-retaining/","title":"Instance retaining (aka ViewModel)","text":"<p>Sometimes it might be necessary to keep an object in memory (retain the instance) in a component when it gets recreated. This commonly used in Android when configuration changes occur. Many Android developers are used to AndroidX <code>ViewModel</code>, however Decompose takes a different approach. The <code>ComponentContext</code> interface extends the <code>InstanceKeeperOwner</code> interface, which provides the <code>InstanceKeeper</code> - a multiplatform abstraction for instances retaining. It is provided by Essenty library (from the same author).</p> <p>The <code>decompose</code> module adds Essenty's <code>instance-keeper</code> module as <code>api</code> dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the <code>InstanceKeeper</code>.</p>"},{"location":"component/instance-retaining/#usage-example","title":"Usage example","text":"<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\n\nclass SomeComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    private val someLogic = instanceKeeper.getOrCreate { SomeLogic() }\n\n    /*\n     * Instances of this class will be retained (not destroyed on configuration changes).\n     * This is equivalent to AndroidX ViewModel.\n     * \u26a0\ufe0f Pay attention to not leak any dependencies, \n     * e.g. don't make this class `inner`, and don't pass dependencies like Activity Context into it.\n     */\n    private class SomeLogic : InstanceKeeper.Instance {\n        override fun onDestroy() {\n            // Clean-up\n        }\n    }\n}\n</code></pre>"},{"location":"component/instance-retaining/#simplified-usage-example","title":"Simplified usage example","text":"<p>Warning</p> <p>The <code>retainedInstance</code> API is experimental since version <code>3.2.0-alpha02</code>, stable since <code>3.2.0</code>.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.retainedInstance\n\nclass SomeComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    private val someLogic = retainedInstance { SomeLogic() }\n\n    /*\n     * Instances of this class will be retained (not destroyed on configuration changes).\n     * This is equivalent to AndroidX ViewModel.\n     * \u26a0\ufe0f Pay attention to not leak any dependencies,\n     * e.g. don't make this class `inner`, and don't pass dependencies like Activity Context into it.\n     */\n    private class SomeLogic : InstanceKeeper.Instance {\n        override fun onDestroy() {\n            // Clean-up\n        }\n    }\n}\n</code></pre>"},{"location":"component/instance-retaining/#retained-components","title":"Retained components","text":"<p>Although discouraged, it is still possible to have all components retained over configuration changes on Android. On the one hand, this makes <code>InstanceKeeper</code> no longer required. But on the other hand, this prevents from supplying dependencies that capture the hosting <code>Activity</code> or <code>Fragment</code>.</p> <p>Warning</p> <p>Pay attention when supplying dependencies to a retained component to avoid leaking the hosting <code>Activity</code> or <code>Fragment</code>.</p> <p>Warning</p> <p>The <code>retainedComponent</code> function must only be called once during the lifetime of the host Activity or Fragment, typically in <code>onCreate</code>. Calling it a second time will result in a crash.</p> <pre><code>import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.retainedComponent\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val root =\n            retainedComponent { componentContext -&gt;\n                DefaultRootComponent(componentContext)\n            }\n    }\n}\n</code></pre>"},{"location":"component/jetpack-component-context/","title":"JetpackComponentContext","text":"<p>The <code>JetpackComponentContext</code> is an extension of the Decompose component system that integrates with Jetpack architecture components. It provides a bridge between Decompose's component system and Jetpack libraries, enabling seamless use of Jetpack <code>Lifecycle</code>, <code>SavedState</code>, and <code>ViewModel</code> functionality within Decompose components.</p> <p>Warning</p> <p>This API is experimental and is available since version <code>3.4.0-alpha03</code>. The API is subject to change.</p>"},{"location":"component/jetpack-component-context/#setup","title":"Setup","text":"<p>Please see the corresponding Installation docs section.</p>"},{"location":"component/jetpack-component-context/#overview","title":"Overview","text":"<p><code>JetpackComponentContext</code> extends <code>GenericComponentContext</code> and implements various Jetpack interfaces:</p> <ul> <li>androidx.lifecycle.LifecycleOwner - provides access to Jetpack's <code>Lifecycle</code>.</li> <li>androidx.savedstate.SavedStateRegistryOwner - enables state preservation via Jetpack's <code>SavedState</code>.</li> <li>androidx.lifecycle.ViewModelStoreOwner - allows using Jetpack <code>ViewModels</code></li> </ul> <p>This integration allows you to use AndroidX Architecture Components directly with Decompose components, combining the benefits of both systems. You can keep using APIs provided by Essenty (such as <code>Lifecycle</code>, <code>StateKeeper</code> or <code>InstanceKeeper</code>), plus you also have access to AndroidX APIs.</p> <p>Note</p> <p>The OnBackPressedDispatcherOwner and the new NavigationEventDispatcherOwner interfaces are not yet supported. Most likely the <code>GenericComponentContext</code> interface will be extending <code>NavigationEventDispatcherOwner</code> in the next major release of Decompose 4.0. See b/425223277 for more information.</p> <p>Note</p> <p>The persistent state saving via <code>SavedStateRegistryOwner</code> is only supported on Android. On all other platforms, the state cannot be serialized at the moment. You can still use StateKeeperOwner, which supports serialization on all platforms. See b/425919375 for more information.</p>"},{"location":"component/jetpack-component-context/#lifecycle","title":"Lifecycle","text":"<p>The <code>Lifecycle</code> provided by <code>JetpackComponentContext</code> extends both AndroidX Lifecycle and Essenty Lifecycle at the same time. This means that in addition to what's provided by Essenty, you can also use AndroidX APIs and extensions, such as LifecycleOwner#lifecycleScope.</p>"},{"location":"component/jetpack-component-context/#usage","title":"Usage","text":""},{"location":"component/jetpack-component-context/#converting-a-component-context-to-jetpackcomponentcontext","title":"Converting a component context to JetpackComponentContext","text":"<p>You can convert any <code>GenericComponentContext</code> to a <code>JetpackComponentContext</code> using the <code>asJetpackComponentContext()</code> extension function:</p> <pre><code>import android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.defaultComponentContext\nimport com.arkivanov.decompose.jetpackcomponentcontext.asJetpackComponentContext\nimport com.arkivanov.sample.shared.root.DefaultRootComponent\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val root =\n            DefaultRootComponent(\n                componentContext = defaultComponentContext().asJetpackComponentContext(),\n            )\n\n        setContent {\n            RootContent(root)\n        }\n    }\n}\n</code></pre>"},{"location":"component/jetpack-component-context/#using-jetpackcomponentcontext","title":"Using JetpackComponentContext","text":"<pre><code>import androidx.lifecycle.SavedStateHandle\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.createSavedStateHandle\nimport androidx.lifecycle.lifecycleScope\nimport com.arkivanov.decompose.jetpackcomponentcontext.JetpackComponentContext\nimport com.arkivanov.decompose.jetpackcomponentcontext.viewModel\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\n\nclass DefaultRootComponent(\n    componentContext: JetpackComponentContext,\n) : RootComponent, JetpackComponentContext by componentContext {\n\n    // Creating a ViewModel using the `viewModel {}` extension function \n    private val viewModel = viewModel { RootViewModel(createSavedStateHandle()) }\n\n    init {\n        lifecycleScope.launch {\n            // A coroutine launched in the Lifecycle scope\n\n            while (true) {\n                viewModel.state.update { it + 1 }\n                delay(1000)\n            }\n        }\n    }\n}\n\nprivate class RootViewModel(\n    savedStateHandle: SavedStateHandle,\n) : ViewModel() {\n    val state: MutableStateFlow&lt;Int&gt; = savedStateHandle.getMutableStateFlow(key = \"state\", initialValue = 0)\n}\n</code></pre>"},{"location":"component/lifecycle/","title":"Lifecycle","text":"<p>The component lifecycle is very similar to the Android Activity lifecycle. The <code>ComponentContext</code> interface extends the <code>LifecycleOwner</code> interface, which provides the <code>Lifecycle</code> - a multiplatform abstraction for lifecycle states and events. It is provided by Essenty library (from the same author).</p> <p>The <code>decompose</code> module adds Essenty's <code>lifecycle</code> module as <code>api</code> dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the <code>Lifecycle</code>.</p> <p>Each component has its own lifecycle. The lifecycle of a child component can not be longer than its parent's lifecycle.</p> <p></p>"},{"location":"component/lifecycle/#usage-example","title":"Usage example","text":"<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.lifecycle.Lifecycle\nimport com.arkivanov.essenty.lifecycle.doOnCreate\nimport com.arkivanov.essenty.lifecycle.subscribe\n\nclass SomeComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    init {\n        lifecycle.subscribe(\n            object : Lifecycle.Callbacks {\n                override fun onCreate() {\n                    /* Component created */\n                }\n\n                // onStart, onResume, onPause, onStop, onDestroy\n            }\n        )\n\n        lifecycle.subscribe(\n            onCreate = { /* Component created */ },\n            // onStart, onResume, onPause, onStop, onDestroy\n        )\n\n        lifecycle.doOnCreate { /* Component created */ }\n        // doOnStart, doOnResume, doOnPause, doOnStop, doOnDestroy\n    }\n}\n</code></pre>"},{"location":"component/lifecycle/#managing-the-root-lifecycle","title":"Managing the root lifecycle","text":"<p>When creating a root component, it's required to supply the root lifecycle (see the docs for more information about the root <code>ComponentContext</code>). The way how the root lifecycle is controlled depends on the platform. See Quick Start docs for details and examples.</p>"},{"location":"component/overview/","title":"Component Overview","text":"<p>A component is just a normal class that encapsulates some logic and possibly another (child) components. Every component has its own lifecycle, which is automatically managed by Decompose. So everything encapsulated by a component is scoped. Please head to the Lifecycle documentation page for more information.</p> <p>UI is optional and is pluggable from outside of components. Components do not depend on UI, the UI depends on components.</p> <p>Unlike the traditional approach with <code>ViewModels</code> and navigation from UI (when a <code>ViewModel</code> is passed to a Composable function or a SwiftUI View, etc.), Decompose uses the Component concept for navigation. So the UI is only responsible for displaying the information, and everything else is behind the component boundary. This allows more code to be shared between platforms while keeping the UI layer thinner.</p> <p>Additionally, this approach significantly simplifies testing. A component can be tested by a unit or integration test, often without instrumentation, which is fast and reliable. Plus, various tools can be used for UI testing, including but not limited to screenshot testing.</p>"},{"location":"component/overview/#component-hierarchy","title":"Component hierarchy","text":""},{"location":"component/overview/#pluggable-ui-hierarchy","title":"Pluggable UI hierarchy","text":""},{"location":"component/overview/#typical-component-structure","title":"Typical component structure","text":""},{"location":"component/overview/#componentcontext","title":"ComponentContext","text":"<p>Each component has an associated <code>ComponentContext</code> which implements the following interfaces:</p> <ul> <li><code>LifecycleOwner</code>, provided by Essenty library, so each component has its own lifecycle</li> <li><code>StateKeeperOwner</code>, provided by Essenty library, so you can preserve any state during configuration changes and/or process death</li> <li><code>InstanceKeeperOwner</code>, provided by Essenty library, so you can retain arbitrary object instances in your components (like with AndroidX ViewModels)</li> <li><code>BackHandlerOwner</code>, provided by Essenty library, so each component can handle back button events</li> </ul> <p>So if a component requires any of the above features, just pass the <code>ComponentContext</code> via the component's constructor. You can use the delegation pattern to add the <code>ComponentContext</code> to <code>this</code> scope:</p> <pre><code>import com.arkivanov.decompose.ComponentContext\n\nclass RootComponent(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    // Some code here\n}\n</code></pre> <p>It may also be useful to extract an interface, e.g. for creating separate implementations for Compose/SwiftUI previews, or writing test doubles.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\n\ninterface RootComponent\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    // Some code here\n}\n</code></pre>"},{"location":"component/overview/#root-componentcontext","title":"Root ComponentContext","text":"<p>When instantiating a root component, the <code>ComponentContext</code> should be created manually. There is DefaultComponentContext which is the default implementation class of the <code>ComponentContext</code>.</p> <p>Warning</p> <p>The root <code>ComponentContext</code> and the root component should be always created on the UI thread.</p>"},{"location":"component/overview/#root-componentcontext-in-android","title":"Root ComponentContext in Android","text":"<p>Decompose provides a few handy helper functions for creating the root <code>ComponentContext</code> in Android. The preferred way is to create the root <code>ComponentContext</code> in an <code>Activity</code> or a <code>Fragment</code>.</p>"},{"location":"component/overview/#root-componentcontext-in-activity","title":"Root ComponentContext in Activity","text":"<p>For this case Decompose provides <code>defaultComponentContext()</code> extension function, which can be called in scope of an <code>Activity</code>.</p> <p>Warning</p> <p>The <code>defaultComponentContext</code> function must only be called once during the lifetime of the host Activity or Fragment, typically in <code>onCreate</code>. Calling it a second time will result in a crash.</p> <pre><code>import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val root = DefaultRootComponent(defaultComponentContext())\n    }\n}\n</code></pre>"},{"location":"component/overview/#root-componentcontext-in-fragment","title":"Root ComponentContext in Fragment","text":"<p>Use <code>defaultComponentContext(OnBackPressedDispatcher?)</code> extension function, which can be called in scope of <code>Fragment</code>.</p> <pre><code>import android.os.Bundle\nimport androidx.fragment.app.Fragment\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass SomeFragment : Fragment() {\n    private lateinit var root: RootComponent\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        root =\n            DefaultRootComponent(\n                componentContext = defaultComponentContext(\n                    onBackPressedDispatcher = requireActivity().onBackPressedDispatcher\n                )\n            )\n    }\n}\n</code></pre>"},{"location":"component/overview/#root-componentcontext-in-jetpackjetbrains-compose","title":"Root ComponentContext in Jetpack/JetBrains Compose","text":"<p>It is advised to not create the root <code>ComponentContext</code> (and a root component) directly in a <code>Composable</code> function. Compositions may be performed in a background thread, which may break things. The preferred way is to create the root component on the UI thread outside of Compose.</p> <p>Warning</p> <p>If you can't avoid creating the root component in a <code>Composable</code> function, please make sure you use <code>remember</code>. This will prevent the root component and its <code>ComponentContext</code> from being recreated on each composition.</p>"},{"location":"component/overview/#android-with-compose","title":"Android with Compose","text":"<p>Prefer creating the root <code>ComponentContext</code> (and a root component) before starting Compose, e.g. in an <code>Activity</code> or a <code>Fragment</code>.</p> <pre><code>import android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Create the root component before starting Compose\n        val root = DefaultRootComponent(componentContext = defaultComponentContext())\n\n        // Start Compose\n        setContent {\n            // The rest of the code\n        }\n    }\n}\n</code></pre>"},{"location":"component/overview/#jvmdesktop-with-compose","title":"JVM/Desktop with Compose","text":"<p>Make sure you always create the root component on the UI thread. Please refer to samples for an example of runOnUiThread function .</p> <pre><code>import androidx.compose.ui.window.application\nimport com.arkivanov.decompose.DefaultComponentContext\n\nfun main() {\n    // Create the root component on the UI thread before starting Compose\n    val root = runOnUiThread { DefaultRootComponent(componentContext = DefaultComponentContext(...)) }\n\n    // Start Compose\n    application {\n        // The rest of the code\n    }\n}\n</code></pre>"},{"location":"component/overview/#other-platforms-with-compose","title":"Other platforms with Compose","text":"<p>Prefer creating the root <code>ComponentContext</code> (and a root component) before starting Compose, e.g. in directly in the <code>main</code> function.</p> <pre><code>import androidx.compose.ui.window.application\nimport com.arkivanov.decompose.DefaultComponentContext\n\nfun main() {\n    // Create the root component before starting Compose.\n    // Make sure that this happens on the UI thread.\n    val root = DefaultRootComponent(componentContext = DefaultComponentContext(...))\n\n    // Start Compose\n    application {\n        // The rest of the code\n    }\n}\n</code></pre>"},{"location":"component/overview/#value-and-mutablevalue-state-holders","title":"Value and MutableValue state holders","text":"<p>Value - is a multiplatform way to expose streams of states. It contains the <code>value</code> property, which always returns the current state. It also provides the ability to observe state changes via <code>subscribe</code>/<code>unsubscribe</code> methods. There is MutableValue which is a mutable variant of <code>Value</code>. Since <code>Value</code> is a class (not an interface) with a generic type parameter, it can be used to expose state streams to ObjC/Swift.</p> <p>Using <code>Value</code> is not mandatory, you can use any other state holders, e.g. StateFlow, State, Observable, LiveData, etc.</p> <p>If you are using Jetpack/JetBrains Compose, <code>Value</code> can be observed in Composable functions using one of the Compose extension modules.</p> <p>Warning</p> <p>Even though both <code>Value</code> and <code>MutableValue</code> are thread-safe, it's recommended to subscribe and update it only on the main thread.</p>"},{"location":"component/overview/#why-not-stateflow","title":"Why not StateFlow?","text":"<p>Decompose uses <code>Value</code> to avoid dependency on Kotlin coroutines. One may prefer using Reaktive, RxJava, etc. instead of coroutines. It also provides better interoperability with ObjC/Swift and simplifies testing. Feel free to convert <code>Value</code> to <code>StateFlow</code> or any other state holder if you need it.</p>"},{"location":"component/overview/#examples","title":"Examples","text":""},{"location":"component/overview/#simplest-component-example","title":"Simplest Component Example","text":"<p>Here is an example of simple Counter component:</p> <pre><code>import com.arkivanov.decompose.value.MutableValue\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.decompose.value.update\n\nclass Counter {\n    private val _state = MutableValue(State())\n    val state: Value&lt;State&gt; = _state\n\n    fun increment() {\n        _state.update { it.copy(count = it.count + 1) }\n    }\n\n    data class State(val count: Int = 0)\n}\n</code></pre>"},{"location":"component/overview/#jetpackjetbrains-compose-ui-example","title":"Jetpack/JetBrains Compose UI Example","text":"<pre><code>import androidx.compose.foundation.layout.Column\nimport androidx.compose.material.Button\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport com.arkivanov.decompose.extensions.compose.subscribeAsState\n\n@Composable\nfun CounterContent(counter: Counter) {\n    val state by counter.state.subscribeAsState()\n\n    Column {\n        Text(text = state.count.toString())\n\n        Button(onClick = counter::increment) {\n            Text(\"Increment\")\n        }\n    }\n}\n</code></pre>"},{"location":"component/overview/#swiftui-example","title":"SwiftUI Example","text":"<pre><code>struct CounterView: View {\n    private let counter: Counter\n\n    @StateValue\n    private var state: CounterState\n\n    init(_ counter: Counter) {\n        self.counter = counter\n        _state = StateValue(counter.state)\n    }\n\n    var body: some View {\n        VStack(spacing: 8) {\n            Text(state.value.text)\n            Button(action: counter.increment, label: { Text(\"Increment\") })\n        }\n    }\n}\n</code></pre>"},{"location":"component/overview/#what-is-statevalue","title":"What is StateValue","text":"<p>StateValue is a property wrapper for <code>Value</code> that makes it observable in SwiftUI. Unfortunately it does not look possible to publish utils for SwiftUI as a library or framework, so it has to be copied in your project.</p>"},{"location":"component/overview/#more-swift-utilities","title":"More Swift utilities","text":"<p>You can find more useful utilities for SwiftUI in the DecomposeHelpers/ folder:</p> <ul> <li>StackView - an adapter for SwiftUI's <code>NavigationStack</code> with fallback to <code>UINavigationView</code> that works with Decompose's <code>ChildStack</code>. See CountersView.swift.</li> <li>MutableValue - helps to stub Decompose's <code>Value</code>/<code>MutableValue</code> for Preview Components. See <code>PreviewMultiPaneComponent</code> in MultiPaneView.swift.</li> <li>SimpleChildStack - helps to stub Decompose's <code>ChildStack</code> for Preview Components. See <code>PreviewCountersComponent</code> in CountersView.swift.</li> </ul>"},{"location":"component/scopes/","title":"Scoping jobs and subscriptions","text":"<p>Due to the fact that components are lifecycle-aware, it is very easy to manage coroutine scopes and reactive subscriptions.</p>"},{"location":"component/scopes/#creating-a-coroutinescope-in-a-component","title":"Creating a CoroutineScope in a component","text":"<p>There are extensions for <code>CoroutineScope</code> and <code>Lifecycle</code> provided by Essenty.</p> <p>Add the following dependency to your build.gradle file.</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.essenty:lifecycle-coroutines:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.essenty:lifecycle-coroutines:&lt;version&gt;\")\n</code></pre> <p>Use the Essenty extensions to create the <code>CoroutineScope</code>.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.lifecycle.coroutines.coroutineScope\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport kotlin.coroutines.CoroutineContext\n\nclass SomeComponent(\n    componentContext: ComponentContext,\n    mainContext: CoroutineContext,\n    private val ioContext: CoroutineContext,\n) : ComponentContext by componentContext {\n\n    // The scope is automatically cancelled when the component is destroyed\n    private val scope = coroutineScope(mainContext + SupervisorJob())\n\n    fun foo() {\n        scope.launch {\n            val result =\n                withContext(ioContext) {\n                    \"Result\" // Result from background thread\n                }\n\n            println(result) // Handle the result on main thread\n        }\n    }\n}\n</code></pre>"},{"location":"component/scopes/#creating-a-coroutinescope-that-survives-android-configuration-changes","title":"Creating a CoroutineScope that survives Android configuration changes","text":"<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.cancel\nimport kotlinx.coroutines.launch\nimport kotlin.coroutines.CoroutineContext\n\ninternal class SomeRetainedInstance(mainContext: CoroutineContext) : InstanceKeeper.Instance {\n    // The scope survives Android configuration changes\n    private val scope = CoroutineScope(mainContext + SupervisorJob())\n\n    fun foo() {\n        scope.launch {\n            // Do the job\n        }\n    }\n\n    override fun onDestroy() {\n        scope.cancel() // Cancel the scope when the instance is destroyed\n    }\n}\n\nclass SomeComponent(\n    componentContext: ComponentContext,\n    mainContext: CoroutineContext,\n) : ComponentContext by componentContext {\n\n    private val someRetainedInstance = instanceKeeper.getOrCreate { SomeRetainedInstance(mainContext) }\n}\n</code></pre>"},{"location":"component/scopes/#creating-a-reaktive-disposablescope-in-a-component","title":"Creating a Reaktive DisposableScope in a component","text":"<p>There are extensions for <code>DisposableScope</code> and <code>Lifecycle</code> provided by Essenty.</p> <p>Add the following dependency to your build.gradle file.</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.essenty:lifecycle-reaktive:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.essenty:lifecycle-reaktive:&lt;version&gt;\")\n</code></pre> <p>Use the Essenty extensions to create the <code>DisposableScope</code>.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.sample.shared.multipane.utils.disposableScope\nimport com.badoo.reaktive.disposable.scope.DisposableScope\nimport com.badoo.reaktive.scheduler.ioScheduler\nimport com.badoo.reaktive.scheduler.mainScheduler\nimport com.badoo.reaktive.single.observeOn\nimport com.badoo.reaktive.single.singleFromFunction\nimport com.badoo.reaktive.single.subscribeOn\n\nclass SomeComponent(\n    componentContext: ComponentContext,\n) : ComponentContext by componentContext,\n    // The scope is automatically disposed when the component is destroyed\n    DisposableScope by componentContext.disposableScope() {\n\n    fun foo() {\n        singleFromFunction {\n            \"Result\" // Result from background thread\n        }\n            .subscribeOn(ioScheduler)\n            .observeOn(mainScheduler)\n            .subscribeScoped { // Subscribe using the DisposableScope\n                println(it) // Handle the result on main thread\n            }\n    }\n}\n</code></pre>"},{"location":"component/scopes/#creating-a-reaktive-disposablescope-that-survives-android-configuration-changes","title":"Creating a Reaktive DisposableScope that survives Android configuration changes","text":"<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\nimport com.badoo.reaktive.completable.completableFromFunction\nimport com.badoo.reaktive.disposable.scope.DisposableScope\n\ninternal class SomeRetainedInstance : InstanceKeeper.Instance,\n    // The scope survives Android configuration changes\n    DisposableScope by DisposableScope() {\n\n    fun foo() {\n        completableFromFunction {\n            // Do the job\n        }.subscribeScoped()\n    }\n\n    override fun onDestroy() {\n        dispose() // Dispose the scope when the instance is destroyed\n    }\n}\n\nclass SomeComponent(\n    componentContext: ComponentContext,\n) : ComponentContext by componentContext {\n\n    private val someRetainedInstance = instanceKeeper.getOrCreate { SomeRetainedInstance() }\n}\n</code></pre>"},{"location":"component/state-preservation/","title":"State preservation (aka SavedStateHandle)","text":"<p>Sometimes it might be necessary to preserve some persistent state or data in a component when it gets destroyed (e.g. killed by the system). A very common use case is Android Activity recreation due to configuration changes, or process death on Android or iOS. Many Android developers are used to AndroidX <code>SavedStateHandle</code>, however Decompose takes a different approach. The <code>ComponentContext</code> interface extends the <code>StateKeeperOwner</code> interface, which provides the <code>StateKeeper</code> API - a multiplatform abstraction for state preservation. It is provided by Essenty library (from the same author).</p> <p>The <code>decompose</code> module adds Essenty's <code>state-keeper</code> module as <code>api</code> dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the <code>StateKeeper</code> API.</p> <p>Decompose relies on kotlinx-serialization library, which makes it easy to save and restore the state on all platforms.</p>"},{"location":"component/state-preservation/#usage-examples","title":"Usage examples","text":"Saving state in a component<pre><code>import com.arkivanov.decompose.ComponentContext\nimport kotlinx.serialization.Serializable\n\nclass SomeComponent(componentContext: ComponentContext) : ComponentContext by componentContext {\n\n    // Either restore the previously saved state or create a new (initial) one\n    private var state: State = stateKeeper.consume(key = \"SAVED_STATE\", strategy = State.serializer()) ?: State()\n\n    init {\n        stateKeeper.register(key = \"SAVED_STATE\", strategy = State.serializer()) {\n            state // Called when it's time to save the state\n        }\n    }\n\n    @Serializable // Comes from kotlinx-serialization\n    private class State(val someValue: Int = 0)\n}\n</code></pre> Saving state of a retained instance<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\nimport com.arkivanov.sample.shared.SomeStatefulEntity.State\nimport kotlinx.serialization.Serializable\n\nclass SomeComponent(componentContext: ComponentContext) : ComponentContext by componentContext {\n    private val statefulEntity =\n        instanceKeeper.getOrCreate {\n            SomeStatefulEntity(savedState = stateKeeper.consume(key = \"SAVED_STATE\", strategy = State.serializer()))\n        }\n\n    init {\n        stateKeeper.register(key = \"SAVED_STATE\", strategy = State.serializer(), supplier = statefulEntity::state)\n    }\n}\n\nclass SomeStatefulEntity(savedState: State?) : InstanceKeeper.Instance {\n    var state: State = savedState ?: State()\n        private set\n\n    @Serializable\n    data class State(val someValue: Int = 0)\n}\n</code></pre>"},{"location":"component/state-preservation/#simplified-state-preservation","title":"Simplified state preservation","text":"<p>Warning</p> <p>The <code>saveable</code> API is experimental since version <code>3.2.0-alpha02</code>.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.statekeeper.saveable\nimport kotlinx.serialization.Serializable\n\nclass SomeComponent(componentContext: ComponentContext) : ComponentContext by componentContext {\n    private var state: State by saveable(serializer = State.serializer(), init = ::State)\n\n    @Serializable // Comes from kotlinx-serialization\n    private data class State(val someValue: Int = 0)\n}\n</code></pre>"},{"location":"component/state-preservation/#simplified-state-preservation-of-a-retained-instance","title":"Simplified state preservation of a retained instance","text":"<p>Warning</p> <p>The <code>retainedInstance</code> API is experimental since version <code>3.2.0-alpha02</code>, stable since <code>3.2.0</code>.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.retainedInstance\nimport com.arkivanov.essenty.statekeeper.saveable\nimport com.arkivanov.sample.shared.SomeStatefulEntity.State\nimport kotlinx.serialization.Serializable\n\nclass SomeComponent(componentContext: ComponentContext) : ComponentContext by componentContext {\n    private val statefulEntity by saveable(serializer = State.serializer(), state = { it.state }) { savedState -&gt;\n        retainedInstance {\n            SomeStatefulEntity(savedState = savedState)\n        }\n    }\n}\n\nclass SomeStatefulEntity(savedState: State?) : InstanceKeeper.Instance {\n    var state: State = savedState ?: State()\n        private set\n\n    @Serializable\n    data class State(val someValue: Int = 0)\n}\n</code></pre>"},{"location":"component/state-preservation/#saving-state-on-non-android-targets","title":"Saving state on non-Android targets","text":"<p>Thanks to <code>kotlinx-serialization</code> the state can be serialized as JSON string and encoded as usual via <code>NSCoder</code> (iOS), file system (JVM), <code>localStorage</code> (Web), etc.</p>"},{"location":"extensions/android/","title":"Extensions for Android views","text":"<p>Experimental extensions and utilities for easier integration of Decompose with Android views.</p>"},{"location":"extensions/android/#setup","title":"Setup","text":"<p>Extensions for Android views are provided by the <code>extensions-android</code> module.</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:extensions-android:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:extensions-android:&lt;version&gt;\")\n</code></pre>"},{"location":"extensions/android/#content","title":"Content","text":"<p>Decompose is primarily designed for better integration with declarative UI frameworks, such as Jetpack/JetBrains Compose, SwiftUI, Kotlin/React, etc. However it still can be used with Android views. Because the main Decompose functionality is separate from UI, the latter has to be plugged externally. This module provides some essential extensions and utilities to improve the experience.</p>"},{"location":"extensions/android/#viewcontext","title":"ViewContext","text":"<p>As mentioned before, Decompose is not aware of any UI. Because the UI is plugged externally, it needs its own <code>Lifecycle</code>. The idea is to supply every view sub-tree with ViewContext, which exposes the following properties:</p> <p><code>parent</code> - a <code>ViewGroup</code> where the view sub-tree should be inflated <code>lifecycle</code> - a <code>Lifecycle</code> of the view sub-tree</p> <p>The following <code>ViewContext</code> extensions are available:</p> <ul> <li><code>val ViewContext.context: Context</code> - returns the Android <code>Context</code> of the view sub-tree</li> <li><code>val ViewContext.resources: Resources</code> - returns the Android <code>Resources</code> of the view sub-tree</li> <li><code>val ViewContext.layoutInflater: LayoutInflater</code> - returns the Android <code>LayoutInflater</code></li> <li><code>fun ViewContext.child(ViewGroup, inflater): ViewContext</code> - creates a child <code>ViewContext</code> with another <code>parent</code> <code>ViewGroup</code>, which shares the <code>Lifecycle</code> of the parent <code>ViewContext</code>. The <code>inflater</code> arguments should inflate a sub-tree of views, but without adding it to the <code>parent</code>.</li> </ul> <p>DefaultViewContext - is a default implementation of <code>ViewContext</code>, which can be used to manually create new instances when needed.</p>"},{"location":"extensions/android/#stackrouterview","title":"StackRouterView","text":"<p>StackRouterView is an Android <code>ViewGroup</code> which observes the <code>Child Stack</code> and manages child views. Once <code>StackRouterView</code> is added to the view hierarchy, just call its <code>children(...)</code> method with the following arguments:</p> <ul> <li><code>stack</code> - the observable <code>Value</code> of <code>ChildStack</code></li> <li><code>lifecycle</code> - the lifecycle of the <code>StackRouterView</code> or its closest parent</li> <li><code>replaceChildView</code> - a function which replaces a currently active child view with a new one, this is also the place where transitions can be applied</li> </ul>"},{"location":"extensions/android/#examples","title":"Examples","text":"<p>You can find an example of using this extension module in the Counter sample.</p> <p>Initializing the root in <code>Activity</code>:</p> <pre><code>import android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.defaultComponentContext\nimport com.arkivanov.decompose.extensions.android.DefaultViewContext\nimport com.arkivanov.essenty.lifecycle.essentyLifecycle\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContentView(R.layout.main_activity)\n\n        val root = DefaultCounterComponent(defaultComponentContext())\n\n        val viewContext =\n            DefaultViewContext(\n                parent = findViewById(R.id.content),\n                lifecycle = essentyLifecycle()\n            )\n\n        viewContext.apply {\n            parent.addView(CounterView(root))\n        }\n    }\n}\n</code></pre> <p>A simple child view:</p> <pre><code>import android.view.View\nimport android.widget.TextView\nimport com.arkivanov.decompose.extensions.android.ViewContext\nimport com.arkivanov.decompose.extensions.android.layoutInflater\nimport com.arkivanov.decompose.value.observe\n\nfun ViewContext.CounterView(component: CounterComponent): View {\n    // Inflate the layout without adding it to the parent\n    val layout = layoutInflater.inflate(R.layout.counter, parent, false)\n\n    // Find required views\n    val counterText: TextView = layout.findViewById(R.id.text_count)\n\n    // Observe Counter models and update the view\n    component.model.observe(lifecycle) { data -&gt;\n        counterText.text = data.text\n    }\n\n    return layout // Return the root of the inflated sub-tree\n}\n</code></pre> <p><code>StackRouterView</code> example:</p> <pre><code>import android.view.View\nimport com.arkivanov.decompose.extensions.android.ViewContext\nimport com.arkivanov.decompose.extensions.android.child\nimport com.arkivanov.decompose.extensions.android.layoutInflater\nimport com.arkivanov.decompose.extensions.android.stack.StackRouterView\n\nfun ViewContext.RootView(component: RootComponent): View {\n    val layout = layoutInflater.inflate(R.layout.counter_root, parent, false)\n    val nextButton: View = layout.findViewById(R.id.button_next)\n    val routerView: StackRouterView = layout.findViewById(R.id.router)\n\n    nextButton.setOnClickListener { counterRoot.onNextChild() }\n\n    // Create a child `ViewContext` for the permanent `CounterView`\n    child(layout.findViewById(R.id.container_counter)) {\n        // Reuse the `CounterView`\n        CounterView(component.counter)\n    }\n\n    // Subscribe the `StackRouterView` to the `ChildStack` changes\n    routerView.children(component.childStack, lifecycle) { parent, newStack, _ -&gt;\n        // Remove all existing views\n        parent.removeAllViews()\n\n        // Add the child view for the currently active child component\n        parent.addView(CounterView(newStack.active.instance))\n    }\n\n    return layout\n}\n</code></pre>"},{"location":"extensions/compose/","title":"Extensions for Jetpack/JetBrains Compose","text":"<p>Extensions and utilities for easier integration of Decompose with Jetpack and Multiplatform Compose.</p>"},{"location":"extensions/compose/#setup","title":"Setup","text":"<p>Please see the corresponding Installation docs section.</p>"},{"location":"extensions/compose/#proguard-rules-for-compose-for-desktop-jvm","title":"ProGuard rules for Compose for Desktop (JVM)","text":"<p>If you support Compose for Desktop, you will need to add the following rule for ProGuard, so that the app works correctly in release mode. See Minification &amp; obfuscation section in Compose docs for more information.</p> <pre><code>-keep class com.arkivanov.decompose.extensions.compose.mainthread.SwingMainThreadChecker\n</code></pre>"},{"location":"extensions/compose/#converting-value-to-state","title":"Converting Value to State","text":"<p>To convert Decompose Value to Compose <code>State</code> use <code>Value&lt;T&gt;.subscribeAsState(): State&lt;T&gt;</code> extension function:</p> <pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.State\nimport androidx.compose.runtime.getValue\nimport com.arkivanov.decompose.extensions.compose.subscribeAsState\nimport com.arkivanov.decompose.value.Value\n\ninterface SomeComponent {\n    val model: Value&lt;Model&gt;\n\n    data class Model(/*...*/)\n}\n\n@Composable\nfun SomeContent(component: SomeComponent) {\n    val model: State&lt;SomeComponent.Model&gt; = component.model.subscribeAsState()\n\n    // Or use the delegation pattern\n    val model by component.model.subscribeAsState()\n}\n</code></pre>"},{"location":"extensions/compose/#controlling-the-lifecycle-on-desktop","title":"Controlling the Lifecycle on Desktop","text":"<p>When using JetBrains Compose, you can have the <code>LifecycleRegistry</code> react to changes in the window state using the <code>LifecycleController()</code> composable. This will trigger appropriate lifecycle events when the window is minimized, restored or closed.</p> <p>It is also possible to manually start the lifecycle using <code>LifecycleRegistry.resume()</code> when the instance is created.</p> <pre><code>import androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\nimport androidx.compose.ui.window.rememberWindowState\nimport com.arkivanov.decompose.DefaultComponentContext\nimport com.arkivanov.decompose.extensions.compose.jetbrains.lifecycle.LifecycleController\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\n\nfun main() {\n    val lifecycle = LifecycleRegistry()\n\n    val root =\n        runOnUiThread {\n            DefaultRootComponent(DefaultComponentContext(lifecycle))\n        }\n\n    application {\n        val windowState = rememberWindowState()\n        LifecycleController(lifecycle, windowState)\n\n        Window(onCloseRequest = ::exitApplication, state = windowState) {\n            RootContent(root)\n        }\n    }\n}\n</code></pre> <p>Warning</p> <p>When using Compose in desktop platforms, make sure to always use one of the methods above, or your components might not receive lifecycle events correctly.</p> <p>Note</p> <p>You can find the <code>runOnUiThread</code> method here.</p>"},{"location":"extensions/compose/#observing-the-navigation-state-manually","title":"Observing the navigation state manually","text":"<p>In most of the cases there is no need to manually observe the navigation state. One of the ways described in the sections below can be used instead. For instance, it's advised to use the <code>Children</code> function to display a stack of components. However, in some cases observing the navigation state manually can be useful. Every navigation model exposes its state as <code>Value&lt;T&gt;</code>, which makes it possible to observe the navigation state in Compose just as any other state.</p> <pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport com.arkivanov.decompose.extensions.compose.subscribeAsState\n\n@Composable\nfun RootContent(component: RootComponent) {\n    val stack by component.childStack.subscribeAsState()\n    // Use the stack variable here\n}\n</code></pre>"},{"location":"extensions/compose/#navigating-between-composable-components","title":"Navigating between Composable components","text":"<p>The Child Stack navigation model provides ChildStack as <code>Value&lt;ChildStack&gt;</code> that can be observed in a <code>Composable</code> component. This makes it possible to switch child <code>Composable</code> components following the <code>ChildStack</code> changes.</p> <p>The Compose extension module provides the Children(...) function which has the following features:</p> <ul> <li>It listens for the <code>ChildStack</code> changes and displays the corresponding child <code>Composable</code> component using the provided slot lambda.</li> <li>It preserves components' UI state (e.g. scrolling position) in the back stack and over configuration changes and process death.</li> <li>It animates between children if there is an <code>animation</code> spec provided.</li> </ul> <p>Here is an example of switching child components on navigation:</p> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.jetbrains.stack.Children\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.value.Value\nimport com.sample.shared.RootComponent.Child.DetailsChild\nimport com.sample.shared.RootComponent.Child.MainChild\n\n// Root\n\ninterface RootComponent {\n    val childStack: Value&lt;ChildStack&lt;*, Child&gt;&gt;\n\n    sealed class Child {\n        data class MainChild(val component: MainComponent) : Child()\n        data class DetailsChild(val component: DetailsComponent) : Child()\n    }\n}\n\n@Composable\nfun RootContent(rootComponent: RootComponent) {\n    Children(rootComponent.childStack) {\n        when (val child = it.instance) {\n            is MainChild -&gt; MainContent(child.component)\n            is DetailsChild -&gt; DetailsContent(child.component)\n        }\n    }\n}\n\n// Children\n\ninterface MainComponent\n\ninterface DetailsComponent\n\n@Composable\nfun MainContent(component: MainComponent) {\n    // Omitted code\n}\n\n@Composable\nfun DetailsContent(component: DetailsComponent) {\n    // Omitted code\n}\n</code></pre>"},{"location":"extensions/compose/#child-slot-navigation-with-compose","title":"Child Slot navigation with Compose","text":"<p>Child Slot navigation model can be used for different purposes. It can be used to just show/hide a certain part of UI, or to present a dialog, or a sheet (like Material Bottom Sheet). Although Decompose doesn't provide any special Compose API for Child Slot, it's pretty easy to do it manually.</p> AlertDialog example<pre><code>import androidx.compose.foundation.layout.width\nimport androidx.compose.material.AlertDialog\nimport androidx.compose.material.Text\nimport androidx.compose.material.TextButton\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport com.arkivanov.decompose.extensions.compose.subscribeAsState\nimport com.arkivanov.decompose.router.slot.ChildSlot\nimport com.arkivanov.decompose.value.Value\n\ninterface RootComponent {\n    val dialog: Value&lt;ChildSlot&lt;*, DialogComponent&gt;&gt;\n}\n\n@Composable\nfun RootContent(component: RootComponent) {\n    val dialogSlot by component.dialog.subscribeAsState()\n    dialogSlot.child?.instance?.also {\n        DialogContent(component = it)\n    }\n}\n\ninterface DialogComponent {\n    fun onDismissClicked()\n}\n\n@Composable\nfun DialogContent(component: DialogComponent) {\n    AlertDialog(\n        onDismissRequest = component::onDismissClicked,\n        title = { Text(text = \"Title\") },\n        text = { Text(text = \"Message\") },\n        confirmButton = {\n            TextButton(onClick = component::onDismissClicked) {\n                Text(\"Dismiss\")\n            }\n        },\n        modifier = Modifier.width(300.dp),\n    )\n}\n</code></pre> <p>Note</p> <p>Child Slot might not be suitable for a Navigation Drawer. This is because the Navigation Drawer can be opened by a drag gesture at any time. The corresponding component should be always created so that it's always ready to be rendered.</p>"},{"location":"extensions/compose/#child-pages-navigation-with-compose","title":"Child Pages navigation with Compose","text":"<p>The Child Pages navigation model provides ChildPages as <code>Value&lt;ChildPages&gt;</code> that can be observed in a <code>Composable</code> component.</p> <p>The Compose extension module provides the ChildPages(...) function which has the following features:</p> <ul> <li>It listens for the <code>ChildPages</code> changes and displays child components using <code>HorizontalPager</code> or <code>VerticalPager</code> (see the related Jetpack Compose documentation).</li> <li>It animates page changes if there is a <code>scrollAnimation</code> spec provided.</li> </ul> Before version 3.2.0-alpha03Since version 3.2.0-alpha03 Example<pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.jetbrains.pages.Pages\nimport com.arkivanov.decompose.extensions.compose.jetbrains.pages.PagesScrollAnimation\n\n@Composable\nfun PagesContent(component: PagesComponent) {\n    Pages(\n        pages = component.pages,\n        onPageSelected = component::selectPage,\n        scrollAnimation = PagesScrollAnimation.Default,\n    ) { _, page -&gt;\n        PageContent(page)\n    }\n}\n\n@Composable\nfun PageContent(component: PageComponent) {\n    // Omitted code\n}\n</code></pre> Example<pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.jetbrains.pages.ChildPages\nimport com.arkivanov.decompose.extensions.compose.jetbrains.pages.PagesScrollAnimation\n\n@Composable\nfun PagesContent(component: PagesComponent) {\n    ChildPages(\n        pages = component.pages,\n        onPageSelected = component::selectPage,\n        scrollAnimation = PagesScrollAnimation.Default,\n    ) { _, page -&gt;\n        PageContent(page)\n    }\n}\n\n@Composable\nfun PageContent(component: PageComponent) {\n    // Omitted code\n}\n</code></pre>"},{"location":"extensions/compose/#child-panels-navigation-with-compose","title":"Child Panels navigation with Compose","text":"<p>Warning</p> <p>This navigation model is experimental since version <code>3.2.0-beta01</code>, the API is subject to change.</p> <p>The Child Panels navigation model provides ChildPanels as <code>Value&lt;ChildPages&gt;</code> that can be observed in a <code>Composable</code> component.</p> <p>The experimental Compose extension module provides the ChildPanels(...) function which has the following features:</p> <ul> <li>It listens for the <code>ChildPanels</code> changes and displays child components (panels) using the provided <code>layout</code>.</li> <li>It animates panel changes using the provided <code>animators</code> and <code>predictiveBackParams</code> specs.</li> <li>It supports displaying either just two panels (Main and Details) or three panels (Main, Details and Extra).</li> </ul> <p>The following arguments are supported.</p> <ul> <li><code>panels</code> - an observable [ChildPanels] to be displayed.</li> <li><code>mainChild</code> - a <code>Composable</code> function that displays the provided Main component.</li> <li><code>detailsChild</code> - a <code>Composable</code> function that displays the provided Details component.</li> <li><code>extraChild</code> - a <code>Composable</code> function that displays the provided Extra component.</li> <li><code>modifier</code> - a <code>Modifier</code> to be applied to a wrapping container.</li> <li><code>layout</code> - an implementation of ChildPanelsLayout responsible for laying out panels. The default layout is HorizontalChildPanelsLayout.</li> <li><code>animators</code> - a ChildPanelsAnimators containing panel animators for different kinds of layouts.</li> <li><code>predictiveBackParams</code> - a function that returns <code>PredictiveBackParams</code> for the specified <code>ChildPanels</code>, or <code>null</code>. The predictive back gesture is enabled if the value returned for the specified <code>ChildStack</code> is not <code>null</code>, and disabled if the returned value is <code>null</code>. Only works if <code>ChildPanels.mode</code> is <code>SINGLE</code>. Also see the related docs below.</li> </ul> <p>The default <code>HorizontalChildPanelsLayout</code> layout places child components (panels) in the following ways.</p> <ul> <li>If the <code>mode</code> is <code>SINGLE</code>, all panels are displayed in a stack. The Main panel, then the Details panel on top (if any), and finally the Extra panel (if any).</li> <li>If the <code>mode</code> is <code>DUAL</code>, the Main panel is always displayed on the left side, and then the Details and the Extra panels are displayed in a stack on the right side (next to the Main panel).</li> <li>If the <code>mode</code> is <code>TRIPLE</code>, all panels are displayed horizontally side by side.</li> </ul> <p>You can use window size classes from the <code>material3-window-size-class</code> package to determine which <code>ChildPanelsMode</code> should be used.</p> WindowSizeClass example<pre><code>import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass\nimport androidx.compose.material3.windowsizeclass.WindowWidthSizeClass.Companion.Expanded\nimport androidx.compose.material3.windowsizeclass.calculateWindowSizeClass\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode.SINGLE\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode.DUAL\n\n@Composable\nfun ChildPanelsModeChangedEffect(onModeChanged: (ChildPanelsMode) -&gt; Unit) {\n    val windowSize = calculateWindowSizeClass()\n    val mode = if (windowSize.widthSizeClass &lt; Expanded) SINGLE else DUAL\n\n    DisposableEffect(mode) {\n        onModeChanged(mode)\n        onDispose {}\n    }\n}\n</code></pre> Basic example<pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.panels.ChildPanels\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode\n\n@Composable\nfun PanelsContent(component: PanelsComponent) {\n    ChildPanelsModeChangedEffect(component::setMode)\n\n    ChildPanels(\n        panels = component.panels,\n        mainChild = { MainContent(it.instance) },\n        detailsChild = { DetailsContent(it.instance) },\n    )\n}\n\n@Composable\nfun MainContent(component: MainComponent) {\n    // Omitted code\n}\n\n@Composable\nfun DetailsContent(component: DetailsComponent) {\n    // Omitted code\n}\n</code></pre> Example with animations<pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.panels.ChildPanels\nimport com.arkivanov.decompose.extensions.compose.experimental.panels.ChildPanelsAnimators\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.materialPredictiveBackAnimatable\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode\n\n@Composable\nfun PanelsContent(component: PanelsComponent) {\n    ChildPanelsModeChangedEffect(component::setMode)\n\n    ChildPanels(\n        panels = component.panels,\n        mainChild = { MainContent(it.instance) },\n        detailsChild = { DetailsContent(it.instance) },\n        animators = ChildPanelsAnimators(single = fade() + scale(), dual = fade() to fade()),\n        predictiveBackParams = { // See the docs below\n            PredictiveBackParams(\n                backHandler = component.backHandler,\n                onBack = component::onBackClicked,\n                animatable = ::materialPredictiveBackAnimatable,\n            )\n        },\n    )\n}\n</code></pre>"},{"location":"extensions/compose/#child-items-navigation-with-compose","title":"Child Items navigation with Compose","text":"<p>Warning</p> <p>This navigation model is experimental and is available since version <code>3.4.0-alpha02</code>, the API is subject to change.</p> <p>The Child Items navigation model provides ChildItems as <code>LazyChildItems</code> that extends both <code>Value&lt;ChildItems&gt;</code> and <code>ItemsNavigator</code>, meaning it can be observed and manipulated in a <code>Composable</code> component.</p> <p>The Compose extension module provides the ChildItemsLifecycleController(...) function which has the following features:</p> <ul> <li>It automatically manages the lifecycle states of child items in lazy lists and grids based on their visibility in the viewport.</li> <li>Items within the viewport are moved to <code>RESUMED</code> state.</li> <li>Items outside the viewport but within the preloading delta are moved to <code>CREATED</code> state.</li> <li>Items outside the viewport and outside the preloading delta are destroyed.</li> </ul> <p>This is particularly useful for optimizing performance in lazy lists/grids by only keeping visible and nearby items active.</p> <p>The controller provides two main variants:</p> <ol> <li>For lazy lists (<code>LazyColumn</code>, <code>LazyRow</code>):</li> </ol> <pre><code>@Composable\nfun &lt;C : Any&gt; ChildItemsLifecycleController(\n    items: LazyChildItems&lt;C, *&gt;,\n    lazyListState: LazyListState,\n    itemIndexConverter: (Int) -&gt; Int,\n    forwardPreloadCount: Int = 0,\n    backwardPreloadCount: Int = 0,\n)\n</code></pre> <ol> <li>For lazy grids (<code>LazyVerticalGrid</code>, <code>LazyHorizontalGrid</code>):</li> </ol> <pre><code>@Composable\nfun &lt;C : Any&gt; ChildItemsLifecycleController(\n    items: LazyChildItems&lt;C, *&gt;,\n    lazyGridState: LazyGridState,\n    itemIndexConverter: (Int) -&gt; Int,\n    forwardPreloadCount: Int = 0,\n    backwardPreloadCount: Int = 0,\n)\n</code></pre> <p>Example:</p> Example<pre><code>import androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.foundation.lazy.rememberLazyListState\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport com.arkivanov.decompose.extensions.compose.lazyitems.ChildItemsLifecycleController\nimport com.arkivanov.decompose.extensions.compose.subscribeAsState\nimport com.arkivanov.sample.shared.foo.ItemComponent\nimport com.arkivanov.sample.shared.foo.ItemsComponent\n\n@Composable\nfun ItemsContent(component: ItemsComponent) {\n    val childItems by component.items.subscribeAsState()\n    val lazyListState = rememberLazyListState()\n\n    LazyColumn(state = lazyListState) {\n        items(items = childItems.items) { config -&gt;\n            ItemContent(component = component.items[config])\n        }\n    }\n\n    ChildItemsLifecycleController(\n        items = component.items,\n        lazyListState = lazyListState,\n        forwardPreloadCount = 3, // Preload 3 components forward\n        backwardPreloadCount = 3, // Preload 3 components backward\n        itemIndexConverter = { it },\n    )\n}\n\n@Composable\nfun ItemContent(component: ItemComponent) {\n    // Omitted code\n}\n</code></pre>"},{"location":"extensions/compose/#animations","title":"Animations","text":"<p>Decompose provides Child Animation API for Compose, as well as some predefined animation specs. To enable child animations you need to pass the <code>animation</code> argument to the <code>Children</code> function. There are predefined animators provided by Decompose.</p>"},{"location":"extensions/compose/#the-new-experimental-animation-api","title":"The new experimental animation API","text":"<p>Since version <code>3.2.0-alpha04</code>, Decompose also provides additional module with experimental animation API. Unlike the default stable API, the new experimental animation API also supports the Shared Element Transitions.</p>"},{"location":"extensions/compose/#adding-the-dependency-with-the-new-animation-api","title":"Adding the dependency with the new animation API","text":"GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:extensions-compose-experimental:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:extensions-compose-experimental:&lt;version&gt;\")\n</code></pre>"},{"location":"extensions/compose/#the-childstack-composable-function","title":"The ChildStack composable function","text":"<p>The ChildStack composable function is a replacement for the default <code>Children</code> composable function and serves the same purpose: displaying Child Stack components with transition animations.</p> Example<pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\n\n@Composable\nfun RootContent(rootComponent: RootComponent) {\n    ChildStack(rootComponent.childStack) {\n        when (val child = it.instance) {\n            is MainChild -&gt; MainContent(child.component)\n            is DetailsChild -&gt; DetailsContent(child.component)\n        }\n    }\n}\n</code></pre>"},{"location":"extensions/compose/#fade-animation","title":"Fade animation","text":"Default APIExperimental API <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(fade()),\n    ) {\n        // Omitted code\n    }\n}\n</code></pre> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(fade()),\n    ) {\n        // Omitted code\n    }\n}\n</code></pre>"},{"location":"extensions/compose/#slide-animation","title":"Slide animation","text":"Default APIExperimental API <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(slide()),\n    ) {\n        // Omitted code\n    }\n}\n</code></pre> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(slide()),\n    ) {\n        // Omitted code\n    }\n}\n</code></pre>"},{"location":"extensions/compose/#combining-animators","title":"Combining animators","text":"<p>It is also possible to combine animators using the <code>plus</code> operator. Please note that the order matters - the right animator is applied after the left animator.</p> Default APIExperimental API <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(fade() + scale())\n    ) {\n        // Omitted code\n    }\n}\n</code></pre> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(fade() + scale())\n    ) {\n        // Omitted code\n    }\n}\n</code></pre> <p></p>"},{"location":"extensions/compose/#separate-animations-for-children","title":"Separate animations for children","text":"<p>Previous examples demonstrate simple cases when all children have the same animation. But it is also possible to specify separate animations for children.</p> Default APIExperimental API <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation { child -&gt;\n            when (child.instance) {\n                is MainChild -&gt; fade() + scale()\n                is DetailsChild -&gt; fade() + slide()\n            }\n        }\n    ) {\n        // Omitted code\n    }\n}\n</code></pre> <p>Not avilable. Please use the veriant below.</p> <p></p> <p>It is also possible to take into account the other child and the animation direction when selecting the animation.</p> Default APIExperimental API <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation { child, otherChild, direction -&gt;\n            // Select and return an animator here\n        }\n    ) {\n        // Omitted code\n    }\n}\n</code></pre> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation { child, otherChild, direction -&gt;\n            // Select and return an animator here\n        }\n    ) {\n        // Omitted code\n    }\n}\n</code></pre>"},{"location":"extensions/compose/#default-stack-animations","title":"Default stack animations","text":"<p>By default, the <code>Children</code> function (and all other functions with stack animations) does not animate stack changes, the change is performed instantly. The default stack animation is configurable so that it's possible to avoid specifying the same animation multiple times.</p> Default APIExperimental API <pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.CompositionLocalProvider\nimport com.arkivanov.decompose.extensions.compose.stack.animation.LocalStackAnimationProvider\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimationProvider\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun App() {\n    CompositionLocalProvider(LocalStackAnimationProvider provides DefaultStackAnimationProvider) {\n        // The rest of the code\n    }\n}\n\nprivate object DefaultStackAnimationProvider : StackAnimationProvider {\n    override fun &lt;C : Any, T : Any&gt; provide(): StackAnimation&lt;C, T&gt; =\n        stackAnimation(slide() + scale())\n}\n</code></pre> <pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.CompositionLocalProvider\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.LocalStackAnimationProvider\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimationProvider\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.slide\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun App() {\n    CompositionLocalProvider(LocalStackAnimationProvider provides DefaultStackAnimationProvider) {\n        // The rest of the code\n    }\n}\n\nprivate object DefaultStackAnimationProvider : StackAnimationProvider {\n    override fun &lt;C : Any, T : Any&gt; provide(): StackAnimation&lt;C, T&gt; =\n        stackAnimation(slide() + scale())\n}\n</code></pre>"},{"location":"extensions/compose/#custom-animations","title":"Custom animations","text":"<p>It is also possible to define custom animations.</p>"},{"location":"extensions/compose/#implementing-stackanimation","title":"Implementing <code>StackAnimation</code>","text":"<p>This is the most flexible low-level API. The animation block receives the current <code>ChildStack</code> and animates children using the provided <code>content</code> slot.</p> Default APIExperimental API <pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.Child\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.decompose.router.stack.ChildStack\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = someAnimation(),\n    ) {\n        // Omitted code\n    }\n}\n\nfun &lt;C : Any, T : Any&gt; someAnimation(): StackAnimation&lt;C, T&gt; =\n    StackAnimation { stack: ChildStack&lt;C, T&gt;,\n                     modifier: Modifier,\n                     content: @Composable (Child.Created&lt;C, T&gt;) -&gt; Unit -&gt;\n        // Render each frame here\n    }\n</code></pre> <pre><code>import androidx.compose.animation.AnimatedVisibilityScope\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.Child\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimation\nimport com.arkivanov.decompose.router.stack.ChildStack\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = someAnimation(),\n    ) {\n        // Omitted code\n    }\n}\n\nfun &lt;C : Any, T : Any&gt; someAnimation(): StackAnimation&lt;C, T&gt; =\n    StackAnimation { stack: ChildStack&lt;C, T&gt;,\n                     modifier: Modifier,\n                     content: @Composable AnimatedVisibilityScope.(Child.Created&lt;C, T&gt;) -&gt; Unit -&gt;\n        // Render each frame here\n    }\n</code></pre>"},{"location":"extensions/compose/#implementing-stackanimator","title":"Implementing <code>StackAnimator</code>","text":"Default APIExperimental API <p>The <code>stackAnimation</code> function takes care of tracking the <code>ChildStack</code> changes. <code>StackAnimator</code> is only responsible for manipulating the <code>Modifier</code> in the given <code>direction</code>, and calling <code>onFinished</code> at the end.</p> <pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.Direction\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(someAnimator()),\n    ) {\n        // Omitted code\n    }\n}\n\nfun someAnimator(): StackAnimator =\n    StackAnimator { direction: Direction,\n                    isInitial: Boolean,\n                    onFinished: () -&gt; Unit,\n                    content: @Composable (Modifier) -&gt; Unit -&gt;\n        // Manipulate the Modifier in the given direction and call onFinished at the end\n    }\n</code></pre> <p>The <code>stackAnimation</code> function takes care of tracking the <code>ChildStack</code> changes. <code>StackAnimator</code> is only responsible for animating a <code>Modifier</code> in the given <code>direction</code> and returning it from the <code>StackAnimator</code> composable block.</p> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.Direction\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(someAnimator()),\n    ) {\n        // Omitted code\n    }\n}\n\nfun someAnimator(): StackAnimator =\n    StackAnimator { direction: Direction -&gt;\n        // Animate and return a Modifier for the given direction\n    }\n</code></pre>"},{"location":"extensions/compose/#using-stackanimator-function","title":"Using <code>stackAnimator</code> function","text":"Default APIExperimental API <p>This is the simplest, but less powerful way. The <code>stackAnimator</code> function takes care of running the animation. Its block has a very limited responsibility: to render the current frame using the provided <code>factor</code> and <code>direction</code>.</p> <pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.Direction\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimator\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = stackAnimation(someAnimator()),\n    ) {\n        // Omitted code\n    }\n}\n\nfun someAnimator(): StackAnimator =\n    stackAnimator { factor: Float,\n                    direction: Direction,\n                    content: (Modifier) -&gt; Unit -&gt;\n        // Render the current frame\n    }\n</code></pre> <p>This is the simplest, but less powerful way. The <code>stackAnimator</code> function takes care of running the animation. Its block has a very limited responsibility: to create and return a <code>Modifier</code> for the current frame using the provided <code>factor</code> and <code>direction</code>.</p> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimator\nimport com.arkivanov.decompose.extensions.compose.stack.animation.Direction\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(someAnimator()),\n    ) {\n        // Omitted code\n    }\n}\n\nfun someAnimator(): StackAnimator =\n    stackAnimator { factor: Float, direction: Direction -&gt;\n        // Create and return a Modifier for the current frame\n    }\n</code></pre> <p>Please refer to the predefined animators (<code>fade</code>, <code>slide</code>, etc.) for implementation examples.</p>"},{"location":"extensions/compose/#shared-element-transitions","title":"Shared Element Transitions","text":"<p>The support of the Shared Element Transitions is experimental since version <code>3.2.0-alpha03</code>. It requires using the new experimental animation API from the extensions-compose-experimental module.</p> <p>The <code>ChildStack</code> composable function exposes AnimatedVisibilityScope as a receiver parameter of the <code>content</code> composable block. The scope is automatically controlled by Decompose when playing the animations, including predictive back gesture animations. So this can be used as usual for Shared Element Transitions. Please follow the Jetpack Compose docs linked above for more information and examples.</p>"},{"location":"extensions/compose/#predictive-back-gesture","title":"Predictive Back Gesture","text":"<p>Warning</p> <p>Predictive Back Gesture support is experimental, the API is subject to change.</p> <p><code>Child Stack</code> supports the new Android Predictive Back Gesture on all platforms. By default, the gesture animation resembles the predictive back design for Android, but it's customizable.</p> <p>If you are using the experimental animation API, then the default gesture animation is the one used by <code>ChildStack</code> composable function. E.g. if you have <code>stackAnimation(slide())</code> specified for <code>ChildStack</code>, then the same slide animation will be playing for predictive back gesture.</p> <p>To enable the gesture, first implement <code>BackHandlerOwner</code> interface in your component with <code>Child Stack</code>, then just pass <code>predictiveBackAnimation</code> to the <code>Children</code> function.</p> RootComponent<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.essenty.backhandler.BackHandlerOwner\n\ninterface RootComponent : BackHandlerOwner {\n    val childStack: Value&lt;ChildStack&lt;...&gt;&gt;\n\n    fun onBackClicked()\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext, BackHandlerOwner {\n    private val navigation = StackNavigation&lt;Config&gt;()\n\n    // ComponentContext already implements BackHandlerOwner, no need to implement it separately\n\n    // Omitted body\n\n    override fun onBackClicked() {\n        navigation.pop()\n    }\n}\n</code></pre> Default APIExperimental API RootContent<pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = predictiveBackAnimation(\n            backHandler = component.backHandler,\n            fallbackAnimation = stackAnimation(fade() + scale()), // Your usual animation here\n            onBack = component::onBackClicked,\n        ),\n    ) {\n        // Omitted code\n    }\n}\n</code></pre> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(\n            animator = fade() + scale(),\n            predictiveBackParams = {\n                PredictiveBackParams(\n                    backHandler = component.backHandler,\n                    onBack = component::onBackClicked,\n                )\n            },\n        ),\n    ) {\n        // Omitted code\n    }\n}\n</code></pre>"},{"location":"extensions/compose/#predefined-animations","title":"Predefined animations","text":"Default APIExperimental API <p>By default, the gesture animation resembles the predictive back design for Android on all platforms. There is no need to do anything special.</p> <p>As mentioned earlier, if you are using the experimental animation API, then the default gesture animation is the one used by <code>ChildStack</code> composable function. Use the following code to enable predictive back design for Android.</p> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.materialPredictiveBackAnimatable\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(\n            animator = fade() + scale(),\n            predictiveBackParams = {\n                PredictiveBackParams(\n                    backHandler = component.backHandler,\n                    onBack = component::onBackClicked,\n                    animatable = ::materialPredictiveBackAnimatable,\n                )\n            },\n        ),\n    ) {\n        // Omitted code\n    }\n}\n</code></pre>"},{"location":"extensions/compose/#standard-android-like-system-animation","title":"Standard Android-like system animation","text":"<p>The <code>androidPredictiveBackAnimatable</code> API resembles the standard back gesture animation used on some Android Upside Down Cake devices (e.g. in system settings on Pixel phones).</p> <p>Starting with Decompose version <code>3.4.0-alpha04</code> the function has been renamed to <code>androidPredictiveBackAnimatableV1</code>. Plus, <code>androidPredictiveBackAnimatableV2</code> was added, resembling the standard back gesture animation from Android Vanilla Ice Cream and Baklava.</p> Default APIExperimental API <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.androidPredictiveBackAnimatable\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = predictiveBackAnimation(\n            backHandler = component.backHandler,\n            fallbackAnimation = stackAnimation(fade() + scale()),\n            selector = { backEvent, _, _ -&gt; androidPredictiveBackAnimatable(backEvent) },\n            onBack = component::onBackClicked,\n        ),\n    ) {\n        // Omitted code\n    }\n}\n</code></pre> <pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.plus\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.scale\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.androidPredictiveBackAnimatable\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = stackAnimation(\n            animator = fade() + scale(),\n            predictiveBackParams = {\n                PredictiveBackParams(\n                    backHandler = component.backHandler,\n                    onBack = component::onBackClicked,\n                    animatable = ::androidPredictiveBackAnimatable,\n                )\n            }\n        ),\n    ) {\n        // Omitted code\n    }\n}\n</code></pre> <p>Example of <code>androidPredictiveBackAnimatableV1</code> animation:</p> <p>Example of <code>androidPredictiveBackAnimatableV2</code> animation:</p>"},{"location":"extensions/compose/#predictive-back-gesture-on-android","title":"Predictive Back Gesture on Android","text":"<p>On Android, the predictive back gesture only works starting with Android T. On Android T, it works only between Activities, if enabled in the system settings. Starting with Android U, the predictive back gesture can be enabled between <code>Child Stack</code> screens inside a single Activity.</p>"},{"location":"extensions/compose/#predictive-back-gesture-on-other-platforms","title":"Predictive Back Gesture on other platforms","text":"<p>On all other platforms, the predictive back gesture can be enabled by showing a special overlay that automatically handles the gesture and manipulates <code>BackDispatcher</code> as needed.</p> <ol> <li>Create <code>BackDispatcher</code> and assign it to a variable.</li> <li>Create the root <code>DefaultComponentContext</code> and pass the previously created <code>BackDispatcher</code> as <code>backHandler</code> argument.</li> <li>Pass the same <code>BackDispatcher</code> to <code>PredictiveBackGestureOverlay</code>.</li> </ol> Using Composable PredictiveBackGestureOverlay on iOS<pre><code>import androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.ArrowBack\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.window.ComposeUIViewController\nimport com.arkivanov.decompose.extensions.compose.PredictiveBackGestureIcon\nimport com.arkivanov.decompose.extensions.compose.PredictiveBackGestureOverlay\nimport com.arkivanov.essenty.backhandler.BackDispatcher\nimport platform.UIKit.UIViewController\n\nfun rootViewController(root: RootComponent, backDispatcher: BackDispatcher): UIViewController =\n    ComposeUIViewController {\n        PredictiveBackGestureOverlay(\n            backDispatcher = backDispatcher,\n            backIcon = { progress, _ -&gt;\n                PredictiveBackGestureIcon(\n                    imageVector = Icons.Default.ArrowBack,\n                    progress = progress,\n                )\n            },\n            modifier = Modifier.fillMaxSize(),\n        ) {\n            RootContent(component = root, modifier = Modifier.fillMaxSize())\n        }\n    }\n</code></pre>"},{"location":"extensions/compose/#predictive-back-gesture-on-ios","title":"Predictive Back Gesture on iOS","text":"<p>It is possible to customize the predictive back gesture, so it looks native-ish on iOS.</p> <p>Add the following code in your <code>commonMain</code> source set.</p> Default APIExperimental API In commonMain source set<pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.essenty.backhandler.BackHandler\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(\n        stack = component.childStack,\n        animation = backAnimation(\n            backHandler = component.backHandler,\n            onBack = component::onBackClicked,\n        ),\n    ) {\n        // Omitted code\n    }\n}\n\nexpect fun &lt;C : Any, T : Any&gt; backAnimation(\n    backHandler: BackHandler,\n    onBack: () -&gt; Unit,\n): StackAnimation&lt;C, T&gt;\n</code></pre> In commonMain source set<pre><code>import androidx.compose.runtime.Composable\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.ChildStack\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimation\nimport com.arkivanov.essenty.backhandler.BackHandler\n\n@Composable\nfun RootContent(component: RootComponent) {\n    ChildStack(\n        stack = component.childStack,\n        animation = backAnimation(\n            backHandler = component.backHandler,\n            onBack = component::onBackClicked,\n        ),\n    ) {\n        // Omitted code\n    }\n}\n\nexpect fun &lt;C : Any, T : Any&gt; backAnimation(\n    backHandler: BackHandler,\n    onBack: () -&gt; Unit,\n): StackAnimation&lt;C, T&gt;\n</code></pre> <p>Add the following code in your <code>androidMain</code> source set.</p> Default APIExperimental API In androidMain source set<pre><code>import com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\nimport com.arkivanov.essenty.backhandler.BackHandler\n\nactual fun &lt;C : Any, T : Any&gt; backAnimation(\n    backHandler: BackHandler,\n    onBack: () -&gt; Unit,\n): StackAnimation&lt;C, T&gt; =\n    predictiveBackAnimation(\n        backHandler = backHandler,\n        fallbackAnimation = stackAnimation(fade()),\n        onBack = onBack,\n    )\n</code></pre> <pre><code>import com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.materialPredictiveBackAnimatable\nimport com.arkivanov.essenty.backhandler.BackHandler\n\nactual fun &lt;C : Any, T : Any&gt; backAnimation(\n    backHandler: BackHandler,\n    onBack: () -&gt; Unit,\n): StackAnimation&lt;C, T&gt; =\n    stackAnimation(\n        animator = fade(),\n        predictiveBackParams = PredictiveBackParams(\n            backHandler = backHandler,\n            onBack = onBack,\n            animatable = ::materialPredictiveBackAnimatable,\n        )\n    )\n</code></pre> <p>Add the following code in your <code>iosMain</code> source set.</p> Default APIExperimental API In iosMain source set<pre><code>import androidx.compose.animation.core.FiniteAnimationSpec\nimport androidx.compose.animation.core.tween\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.drawWithContent\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.layout.layout\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.stack.animation.isFront\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimatable\nimport com.arkivanov.decompose.extensions.compose.stack.animation.predictiveback.predictiveBackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimator\nimport com.arkivanov.essenty.backhandler.BackHandler\n\nactual fun &lt;C : Any, T : Any&gt; backAnimation(\n    backHandler: BackHandler,\n    onBack: () -&gt; Unit,\n): StackAnimation&lt;C, T&gt; =\n    predictiveBackAnimation(\n        backHandler = backHandler,\n        fallbackAnimation = stackAnimation(iosLikeSlide()),\n        selector = { initialBackEvent, _, _ -&gt;\n            predictiveBackAnimatable(\n                initialBackEvent = initialBackEvent,\n                exitModifier = { progress, _ -&gt; Modifier.slideExitModifier(progress = progress) },\n                enterModifier = { progress, _ -&gt; Modifier.slideEnterModifier(progress = progress) },\n            )\n        },\n        onBack = onBack,\n    )\n\nprivate fun iosLikeSlide(animationSpec: FiniteAnimationSpec&lt;Float&gt; = tween()): StackAnimator =\n    stackAnimator(animationSpec = animationSpec) { factor, direction, content -&gt;\n        content(\n            Modifier\n                .then(if (direction.isFront) Modifier else Modifier.fade(factor + 1F))\n                .offsetXFactor(factor = if (direction.isFront) factor else factor * 0.5F)\n        )\n    }\n\nprivate fun Modifier.slideExitModifier(progress: Float): Modifier =\n    offsetXFactor(progress)\n\nprivate fun Modifier.slideEnterModifier(progress: Float): Modifier =\n    fade(progress).offsetXFactor((progress - 1f) * 0.5f)\n\nprivate fun Modifier.fade(factor: Float) =\n    drawWithContent {\n        drawContent()\n        drawRect(color = Color(red = 0F, green = 0F, blue = 0F, alpha = (1F - factor) / 4F))\n    }\n\nprivate fun Modifier.offsetXFactor(factor: Float): Modifier =\n    layout { measurable, constraints -&gt;\n        val placeable = measurable.measure(constraints)\n\n        layout(placeable.width, placeable.height) {\n            placeable.placeRelative(x = (placeable.width.toFloat() * factor).toInt(), y = 0)\n        }\n    }\n</code></pre> <pre><code>import androidx.compose.animation.core.FiniteAnimationSpec\nimport androidx.compose.animation.core.tween\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.drawWithContent\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.layout.layout\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.PredictiveBackParams\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimation\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.StackAnimator\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimation\nimport com.arkivanov.decompose.extensions.compose.experimental.stack.animation.stackAnimator\nimport com.arkivanov.decompose.extensions.compose.stack.animation.isFront\nimport com.arkivanov.essenty.backhandler.BackHandler\n\nactual fun &lt;C : Any, T : Any&gt; backAnimation(\n    backHandler: BackHandler,\n    onBack: () -&gt; Unit,\n): StackAnimation&lt;C, T&gt; =\n    stackAnimation(\n        animator = iosLikeSlide(),\n        predictiveBackParams = {\n            PredictiveBackParams(\n                backHandler = backHandler,\n                onBack = onBack,\n            )\n        },\n    )\n\nprivate fun iosLikeSlide(animationSpec: FiniteAnimationSpec&lt;Float&gt; = tween()): StackAnimator =\n    stackAnimator(animationSpec = animationSpec) { factor, direction -&gt;\n        Modifier\n            .then(if (direction.isFront) Modifier else Modifier.fade(factor + 1F))\n            .offsetXFactor(factor = if (direction.isFront) factor else factor * 0.5F)\n    }\n\nprivate fun Modifier.fade(factor: Float) =\n    drawWithContent {\n        drawContent()\n        drawRect(color = Color(red = 0F, green = 0F, blue = 0F, alpha = (1F - factor) / 4F))\n    }\n\nprivate fun Modifier.offsetXFactor(factor: Float): Modifier =\n    layout { measurable, constraints -&gt;\n        val placeable = measurable.measure(constraints)\n\n        layout(placeable.width, placeable.height) {\n            placeable.placeRelative(x = (placeable.width.toFloat() * factor).toInt(), y = 0)\n        }\n    }\n</code></pre>"},{"location":"extensions/overview/","title":"Extensions Overview","text":"<p>Decompose provides extension modules for various popular libraries and frameworks:</p> <ul> <li>Extensions for Jetpack/JetBrains Compose</li> <li>Extensions for Android views</li> </ul>"},{"location":"getting-started/contributing/","title":"Contributing","text":""},{"location":"getting-started/contributing/#documentation","title":"Documentation","text":"<p>All of the documentation is stored in the <code>docs/</code> folder of this repository and is all written in markdown. The documentation is generated with Material MkDocs, so if you want to see what the changes look like locally it is recommended to use Docker with the Material MkDocs docker image. </p> <pre><code># download the image\ndocker pull squidfunk/mkdocs-material\n\n# run the server locally \ndocker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material\n</code></pre> <p>Then add the new documentation markdown file into the appropriate folder inside <code>docs/</code> and add it to the <code>mkdocs.yml</code> file in the project so that it can be navigated to. Put up a pull request for review. </p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Decompose provides a number of modules, they are all published to Maven Central Repository.</p>"},{"location":"getting-started/installation/#the-main-decompose-module","title":"The main Decompose module","text":"<p>The main functionality is provided by the <code>decompose</code> module. It contains some core features like:</p> <ul> <li>ComponentContext - provides API for components to manage lifecycle, state saving, etc.</li> <li>Value - Multiplatform (Swift-friendly) observable state holder (allows observing state changes in the UI).</li> <li>Child Stack - stack navigation model.</li> <li>defaultComponentContext - creates a default <code>ComponentContext</code> attached to an Activity or Fragment on Android.</li> <li>And many other important APIs.</li> </ul> <p>This module should be imported into build.gradle.kts for shared application module at <code>kotlin.sourceSets.commonMain.dependencies</code>.</p> <p>If you are having Android module (androidApp or composeApp if using KMP Wizard) this dependency also needs to be added into build.gradle.kts for Android module at <code>android.dependencies</code> to allow Android code access to above functionality</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:decompose:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:decompose:&lt;version&gt;\")\n</code></pre>"},{"location":"getting-started/installation/#dependency-on-essenty-library","title":"Dependency on Essenty library","text":"<p>Some functionality is actually provided by Essenty library. Essenty is implemented by the same author and provides very basic things like <code>Lifecycle</code>, <code>StateKeeper</code>, etc. Most important Essenty modules are added to the <code>decompose</code> module as <code>api</code> dependency, so you don't have to add them manually to your project. Please familiarise yourself with Essenty library.</p>"},{"location":"getting-started/installation/#extensions-for-jetpack-and-multiplatform-compose","title":"Extensions for Jetpack and Multiplatform Compose","text":"<p>Compose is currently published in two separate variants:</p> <ul> <li>The one developed and maintained by Google is Android only, called Jetpack Compose.</li> <li>The Kotlin Multiplatform variant of Jetpack Compose maintained by both JetBrains and Google, called Multiplatform Compose.</li> </ul> <p>Decompose provides extensions for Compose and depends on Multiplatform Compose, which makes it also compatible with Android Jetpack Compose. The extensions are used to connect Compose with Decompose components. Please see the corresponding documentation page.</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:extensions-compose:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:extensions-compose:&lt;version&gt;\")\n</code></pre> <p>Supported multiplatform targets: Android, JVM/Desktop, Native/iOS, Native/macOS, JS/Canvas and JS/Wasm.</p>"},{"location":"getting-started/installation/#experimental-extensions-for-jetpack-and-multiplatform-compose","title":"Experimental extensions for Jetpack and Multiplatform Compose","text":"<p>There is also a small set of experimental extensions available for Compose, enabling features like shared transitions, etc. For more information please refer to the corresponding documentation page.</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:extensions-compose-experimental:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:extensions-compose-experimental:&lt;version&gt;\")\n</code></pre> <p>Supported multiplatform targets: Android, JVM/Desktop, Native/iOS, Native/macOS, JS/Canvas and JS/Wasm.</p>"},{"location":"getting-started/installation/#extensions-for-android-views","title":"Extensions for Android views","text":"<p>The <code>extensions-android</code> module provides extensions to connect Android views (older alternative to Compose UI) to Decompose components. Please head to the corresponding documentation page for more information.</p>"},{"location":"getting-started/installation/#gradle-setup","title":"Gradle setup","text":"GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:extensions-android:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:extensions-android:&lt;version&gt;\")\n</code></pre>"},{"location":"getting-started/installation/#jetpackcomponentcontext","title":"JetpackComponentContext","text":"<p>If you want to use AndroidX Architecture Components (such as AndroidX <code>Lifecycle</code>, <code>ViewModel</code> and <code>Saved State</code>) together with Decompose, you can leverage JetpackComponentContext provided by <code>jetpack-component-context</code> module.</p>"},{"location":"getting-started/installation/#gradle-setup_1","title":"Gradle setup","text":"GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:jetpack-component-context:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:jetpack-component-context:&lt;version&gt;\")\n</code></pre>"},{"location":"getting-started/installation/#exporting-decompose-to-ios-framework","title":"Exporting Decompose to iOS Framework","text":"<p>For using Decompose on your iOS project you need to export it to the iOS Framework.</p>"},{"location":"getting-started/installation/#regular-framework","title":"Regular Framework","text":"<pre><code>...\nkotlin {\n    ...\n    targets\n        .filterIsInstance&lt;KotlinNativeTarget&gt;()\n        .filter { it.konanTarget.family == Family.IOS }\n        .forEach {\n            it.binaries.framework {\n                ...\n\n                export(\"com.arkivanov.decompose:decompose:&lt;version&gt;\")\n                export(\"com.arkivanov.essenty:lifecycle:&lt;essenty_version&gt;\")\n\n                // Optional, only if you need state preservation on Darwin (Apple) targets\n                export(\"com.arkivanov.essenty:state-keeper:&lt;essenty_version&gt;\")\n            }\n        }\n    ...\n}\n...\n</code></pre>"},{"location":"getting-started/installation/#cocoapods","title":"CocoaPods","text":"<pre><code>...\nkotlin {\n    ...\n    cocoapods {\n        ...\n        framework {\n            ...\n\n            export(\"com.arkivanov.decompose:decompose:&lt;version&gt;\")\n            export(\"com.arkivanov.essenty:lifecycle:&lt;essenty_version&gt;\")\n\n            // Optional, only if you need state preservation on Darwin (Apple) targets\n            export(\"com.arkivanov.essenty:state-keeper:&lt;essenty_version&gt;\")\n        }\n    }\n    ...\n}\n...\n</code></pre>"},{"location":"getting-started/license/","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>\u00a9 You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy] [name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"getting-started/quick-start/","title":"Quick start","text":"<p>Please see the template repository which can be used to kick-start your project.</p> <p>Should you have any questions or ideas - there is Discussions section. Also welcome to the Kotlin Slack channel - #decompose! You can also try using DeepWiki to ask your questions live!</p>"},{"location":"getting-started/quick-start/#a-simplest-component","title":"A simplest component","text":"<pre><code>class RootComponent\n</code></pre> <p>Yes, the simplest component is just a normal class. No need to extend a class from the library, or implement an interface.</p>"},{"location":"getting-started/quick-start/#extracting-an-interface","title":"Extracting an interface","text":"<pre><code>interface RootComponent\n\nclass DefaultRootComponent : RootComponent\n</code></pre> <p>It's often useful to extract an interface for a component. It makes it possible to create test doubles for integration tests (e.g. testing navigation in a container component), or fake implementations for UI previews (e.g. for Compose or SwiftUI).</p>"},{"location":"getting-started/quick-start/#componentcontext","title":"ComponentContext","text":"<p>ComponentContext is probably the most important concept of Decompose. It is an interface that provides access to various tools, like lifecycle, state preservation, instance retaining (aka Android ViewModel), back button handling, etc. Each component has its own <code>ComponentContext</code> provided by Decompose.</p> <p>If your component requires <code>ComponentContext</code>, just pass it via constructor. You can also use the delegation pattern to add <code>ComponentContext</code> to <code>this</code> scope.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    init {\n        lifecycle... // Access the Lifecycle\n        stateKeeper... // Access the StateKeeper\n        instanceKeeper... // Access the InstanceKeeper\n        backHandler... // Access the BackHandler\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#observable-state-and-callbacks","title":"Observable state and callbacks","text":"<p>There are multiple ways of exposing an observable state from a component.</p>"},{"location":"getting-started/quick-start/#using-value-from-decompose","title":"Using Value from Decompose","text":"<p>Decompose provides an observable state holder - <code>Value</code>. It offers great integration with various UI frameworks, such as Compose, SwiftUI, Kotlin/React, etc. You can also convert Reaktive <code>Observable</code> or coroutines <code>Flow</code> to <code>Value</code>, if needed.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.value.MutableValue\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.sample.shared.ListComponent.Model\n\ninterface ListComponent {\n    val model: Value&lt;Model&gt;\n\n    fun onItemClicked(item: String)\n\n    data class Model(\n        val items: List&lt;String&gt;,\n    )\n}\n\nclass DefaultListComponent(\n    componentContext: ComponentContext,\n    private val onItemSelected: (item: String) -&gt; Unit,\n) : ListComponent {\n    override val model: Value&lt;Model&gt; =\n        MutableValue(Model(items = List(100) { \"Item $it\" }))\n\n    override fun onItemClicked(item: String) {\n        onItemSelected(item)\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#observing-value-in-compose","title":"Observing Value in Compose","text":"<p>Observing <code>Value</code> in Compose is easy, just use the <code>subscribeAsState</code> extension function.</p> <pre><code>import androidx.compose.foundation.clickable\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.extensions.compose.subscribeAsState\n\n@Composable\nfun ListContent(component: ListComponent, modifier: Modifier = Modifier) {\n    val model by component.model.subscribeAsState()\n\n    LazyColumn {\n        items(items = model.items) { item -&gt;\n            Text(\n                text = item,\n                modifier = Modifier.clickable { component.onItemClicked(item = item) },\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#observing-value-in-swiftui","title":"Observing Value in SwiftUI","text":"<pre><code>struct DetailsView: View {\n    private let list: ListComponent\n\n    @StateValue\n    private var model: ListComponentModel\n\n    init(_ list: ListComponent) {\n        self.list = list\n        _model = StateValue(list.model)\n    }\n\n    var body: some View {\n        List(model.items, ...) { item in\n            // Display the item\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#what-is-statevalue","title":"What is StateValue","text":"<p>StateValue is a property wrapper for <code>Value</code> that makes it observable in SwiftUI. Unfortunately it does not look possible to publish utils for SwiftUI as a library or framework, so it has to be copied in your project.</p>"},{"location":"getting-started/quick-start/#observing-value-in-other-ui-frameworks","title":"Observing Value in other UI Frameworks","text":"<p>Please refer to the docs for information about other platforms and UI frameworks.</p>"},{"location":"getting-started/quick-start/#using-reaktive-or-coroutines","title":"Using Reaktive or coroutines","text":"<p>The state can be also exposed using Reaktive <code>Observable</code> or coroutines <code>Flow</code>, or any other reactive library. Follow best practices recommended for the reactive library of your choice.</p>"},{"location":"getting-started/quick-start/#navigation","title":"Navigation","text":"<p>Decompose provides various ways to navigate, you can find more information in the docs. The most common navigation pattern is Child Stack.</p>"},{"location":"getting-started/quick-start/#component-configurations","title":"Component configurations","text":"<p>Child component configurations is another important concepts of Decompose. It allows supplying type safe arguments, as well as any kind of dependencies to child components.</p> <p>Each child component is represented by a persistent configuration class. A configuration class denotes which child component should be instantiated, and holds persistent arguments required for instantiation. A configuration class must be defined for every child component.</p> <p>Decompose relies on kotlinx-serialization library for persistence. Each configuration class should be annotated as <code>@Serializable</code>, or a custom serializer should be implemented manually.</p>"},{"location":"getting-started/quick-start/#using-the-child-stack","title":"Using the Child Stack","text":"<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport com.arkivanov.decompose.router.stack.pop\nimport com.arkivanov.decompose.router.stack.popTo\nimport com.arkivanov.decompose.router.stack.push\nimport com.arkivanov.decompose.value.Value\nimport com.sample.shared.RootComponent.Child.DetailsChild\nimport com.sample.shared.RootComponent.Child.ListChild\nimport kotlinx.serialization.Serializable\n\ninterface RootComponent {\n\n    val stack: Value&lt;ChildStack&lt;*, Child&gt;&gt;\n\n    // It's possible to pop multiple screens at a time on iOS\n    fun onBackClicked(toIndex: Int)\n\n    // Defines all possible child components\n    sealed class Child {\n        class ListChild(val component: ListComponent) : Child()\n        class DetailsChild(val component: DetailsComponent) : Child()\n    }\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    private val navigation = StackNavigation&lt;Config&gt;()\n\n    override val stack: Value&lt;ChildStack&lt;*, RootComponent.Child&gt;&gt; =\n        childStack(\n            source = navigation,\n            serializer = Config.serializer(),\n            initialConfiguration = Config.List, // The initial child component is List\n            handleBackButton = true, // Automatically pop from the stack on back button presses\n            childFactory = ::child,\n        )\n\n    private fun child(config: Config, componentContext: ComponentContext): RootComponent.Child =\n        when (config) {\n            is Config.List -&gt; ListChild(listComponent(componentContext))\n            is Config.Details -&gt; DetailsChild(detailsComponent(componentContext, config))\n        }\n\n    private fun listComponent(componentContext: ComponentContext): ListComponent =\n        DefaultListComponent(\n            componentContext = componentContext,\n            onItemSelected = { item: String -&gt; // Supply dependencies and callbacks\n                navigation.push(Config.Details(item = item)) // Push the details component\n            },\n        )\n\n    private fun detailsComponent(componentContext: ComponentContext, config: Config.Details): DetailsComponent =\n        DefaultDetailsComponent(\n            componentContext = componentContext,\n            item = config.item, // Supply arguments from the configuration\n            onFinished = navigation::pop, // Pop the details component\n        )\n\n    override fun onBackClicked(toIndex: Int) {\n        navigation.popTo(index = toIndex)\n    }\n\n    @Serializable // kotlinx-serialization plugin must be applied\n    private sealed interface Config {\n        @Serializable\n        data object List : Config\n\n        @Serializable\n        data class Details(val item: String) : Config\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#child-stack-with-compose","title":"Child Stack with Compose","text":"<pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.extensions.compose.jetbrains.stack.Children\nimport com.arkivanov.decompose.extensions.compose.jetbrains.stack.animation.fade\nimport com.arkivanov.decompose.extensions.compose.jetbrains.stack.animation.stackAnimation\nimport com.sample.shared.RootComponent.Child.ListChild\nimport com.sample.shared.RootComponent.Child.DetailsChild\n\n@Composable\nfun RootContent(component: RootComponent, modifier: Modifier = Modifier) {\n    Children(\n        stack = component.stack,\n        modifier = modifier,\n        animation = stackAnimation(fade()),\n    ) {\n        when (val child = it.instance) {\n            is ListChild -&gt; ListContent(component = child.component)\n            is DetailsChild -&gt; DetailsContent(component = child.component)\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#child-stack-with-swiftui","title":"Child Stack with SwiftUI","text":"<pre><code>struct RootView: View {\n    let root: RootComponent\n\n    var body: some View {\n        StackView(\n            stackValue: StateValue(root.stack),\n            getTitle: {\n                switch $0 {\n                case is RootComponentChild.ListChild: return \"List\"\n                case is RootComponentChild.DetailsChild: return \"Details\"\n                default: return \"\"\n                }\n            },\n            onBack: root.onBackClicked,\n            childContent: {\n                switch $0 {\n                case let child as RootComponentChild.ListChild: ListView(child.component)\n                case let child as RootComponentChild.DetailsChild: DetailsView(child.component)\n                default: EmptyView()\n                }\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#what-is-stackview","title":"What is StackView?","text":"<p>StackView is a view that displays <code>Child Stack</code> using the native SwiftUI navigation and providing the native UX. For the same reason, it has to be copied in your project.</p>"},{"location":"getting-started/quick-start/#child-stack-with-other-ui-frameworks","title":"Child Stack with other UI Frameworks","text":"<p>Please refer to samples for integrations with other UI frameworks.</p>"},{"location":"getting-started/quick-start/#initializing-a-root-component","title":"Initializing a root component","text":""},{"location":"getting-started/quick-start/#android-with-compose","title":"Android with Compose","text":"<p>Use <code>defaultComponentContext</code> extension function to create the root <code>ComponentContext</code> in an <code>Activity</code> or a <code>Fragment</code>.</p> <p>Warning</p> <p>The <code>defaultComponentContext</code> function must only be called once during the lifetime of the host Activity or Fragment, typically in <code>onCreate</code>. Calling it a second time will result in a crash.</p> <pre><code>import android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Surface\nimport androidx.compose.ui.Modifier\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Always create the root component outside Compose on the main thread\n        val root =\n            DefaultRootComponent(\n                componentContext = defaultComponentContext(),\n            )\n\n        setContent {\n            MaterialTheme {\n                Surface {\n                    RootContent(component = root, modifier = Modifier.fillMaxSize())\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#desktop-with-compose","title":"Desktop with Compose","text":"<p>Use <code>LifecycleController</code> to bind the root lifecycle with the main window state. See an example of <code>runOnUiThread</code> function here - Utils.kt.</p> <pre><code>import androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Surface\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\nimport androidx.compose.ui.window.rememberWindowState\nimport com.arkivanov.decompose.DefaultComponentContext\nimport com.arkivanov.decompose.extensions.compose.jetbrains.lifecycle.LifecycleController\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\nimport com.arkivanov.sample.shared.DefaultRootComponent\nimport com.arkivanov.sample.shared.RootContent\n\nfun main() {\n    val lifecycle = LifecycleRegistry()\n\n    // Always create the root component outside Compose on the UI thread\n    val root =\n        runOnUiThread {\n            DefaultRootComponent(\n                componentContext = DefaultComponentContext(lifecycle = lifecycle),\n            )\n        }\n\n    application {\n        val windowState = rememberWindowState()\n\n        LifecycleController(lifecycle, windowState)\n\n        Window(\n            onCloseRequest = ::exitApplication,\n            state = windowState,\n            title = \"My Application\"\n        ) {\n            MaterialTheme {\n                Surface {\n                    RootContent(component = root, modifier = Modifier.fillMaxSize())\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#ios-with-compose-or-swiftui-with-the-experimental-applicationlifecycle","title":"iOS with Compose or SwiftUI (with the experimental ApplicationLifecycle)","text":"<p>Warning</p> <p>Use this approach only if your root component lives in the app scope (e.g. have only one UIViewController holding the root component).</p> <p>Step 1. In your Xcode project declare a simple <code>AppDelegate</code> containing the <code>RootComponent</code>.</p> <pre><code>class AppDelegate: NSObject, UIApplicationDelegate {\n    let root: RootComponent = DefaultRootComponent(\n        componentContext: DefaultComponentContext(lifecycle: ApplicationLifecycle())\n    )\n}\n</code></pre> <p>Step 2. If using Compose, create a Kotlin file named <code>RootViewController.kt</code> in your shared module in <code>iosMain</code> source set with the following content. Then create <code>RootView</code> displaying <code>RootViewController</code>.</p> <pre><code>import androidx.compose.ui.window.ComposeUIViewController\nimport platform.UIKit.UIViewController\n\nfun rootViewController(root: RootComponent): UIViewController =\n    ComposeUIViewController {\n        // Render the UI here\n    }\n</code></pre> <pre><code>struct RootView: UIViewControllerRepresentable {\n    let root: RootComponent\n\n    func makeUIViewController(context: Context) -&gt; UIViewController {\n        return RootViewControllerKt.rootViewController(root: root)\n    }\n\n    func updateUIViewController(_ uiViewController: UIViewController, context: Context) {\n    }\n}\n</code></pre> <p>Step 3. Use <code>AppDelegate</code> in your application entrypoint.</p> <pre><code>@main\nstruct iOSApp: App {\n    @UIApplicationDelegateAdaptor(AppDelegate.self)\n    var appDelegate: AppDelegate\n\n    var body: some Scene {\n        WindowGroup {\n            RootView(root: appDelegate.root)\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#ios-with-compose-or-swiftui-without-the-experimental-applicationlifecycle","title":"iOS with Compose or SwiftUI (without the experimental ApplicationLifecycle)","text":"<p>Step 1. Create <code>RootHolder</code> class that holds the root component and its lifecycle.</p> <pre><code>class RootHolder : ObservableObject {\n    let lifecycle: LifecycleRegistry\n    let root: RootComponent\n\n    init() {\n        lifecycle = LifecycleRegistryKt.LifecycleRegistry()\n\n        root = DefaultRootComponent(\n            componentContext: DefaultComponentContext(lifecycle: lifecycle)\n        )\n\n        LifecycleRegistryExtKt.create(lifecycle)\n    }\n\n    deinit {\n        // Destroy the root component before it is deallocated\n        LifecycleRegistryExtKt.destroy(lifecycle)\n    }\n}\n</code></pre> <p>Step 2. Declare a simple <code>AppDelegate</code> containing <code>RootHolder</code></p> <pre><code>class AppDelegate: NSObject, UIApplicationDelegate {\n    let rootHolder: RootHolder = RootHolder()\n}\n</code></pre> <p>Step 3. If using Compose, create a Kotlin file named <code>RootViewController.kt</code> in your shared module in <code>iosMain</code> source set with the following content. Then create <code>RootView</code> displaying <code>RootViewController</code>.</p> <pre><code>import androidx.compose.ui.window.ComposeUIViewController\nimport platform.UIKit.UIViewController\n\nfun rootViewController(root: RootComponent): UIViewController =\n    ComposeUIViewController {\n        // Render the UI here\n    }\n</code></pre> <pre><code>struct RootView: UIViewControllerRepresentable {\n    let root: RootComponent\n\n    func makeUIViewController(context: Context) -&gt; UIViewController {\n        return RootViewControllerKt.rootViewController(root: root)\n    }\n\n    func updateUIViewController(_ uiViewController: UIViewController, context: Context) {\n    }\n}\n</code></pre> <p>Step 4. Use <code>AppDelegate</code> in your <code>App</code> entrypoint.</p> <pre><code>@main\nstruct iOSApp: App {\n    @UIApplicationDelegateAdaptor(AppDelegate.self)\n    var appDelegate: AppDelegate\n\n    @Environment(\\.scenePhase)\n    var scenePhase: ScenePhase\n\n    var rootHolder: RootHolder { appDelegate.rootHolder }\n\n    var body: some Scene {\n        WindowGroup {\n            RootView(rootHolder.root)\n                .onChange(of: scenePhase) { newPhase in\n                    switch newPhase {\n                    case .background: LifecycleRegistryExtKt.stop(rootHolder.lifecycle)\n                    case .inactive: LifecycleRegistryExtKt.pause(rootHolder.lifecycle)\n                    case .active: LifecycleRegistryExtKt.resume(rootHolder.lifecycle)\n                    @unknown default: break\n                    }\n                }\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#javascript-web","title":"JavaScript (Web)","text":"<p>In the place where you create your <code>RootComponent</code>:</p> <ol> <li>Initialize a <code>LifecycleRegistry</code>.</li> <li>Pass it into the root <code>ComponentContext</code>.</li> <li>Attach the <code>LifecycleRegistry</code> to the <code>document</code> via an extension function.</li> </ol> <pre><code>import com.arkivanov.decompose.DefaultComponentContext\nimport com.arkivanov.decompose.ExperimentalDecomposeApi\nimport com.arkivanov.decompose.router.stack.webhistory.DefaultWebHistoryController\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\nimport com.arkivanov.essenty.lifecycle.resume\nimport com.arkivanov.essenty.lifecycle.stop\nimport kotlinx.browser.window\nimport react.create\nimport react.dom.client.createRoot\nimport web.dom.DocumentVisibilityState\nimport web.dom.document\nimport web.events.EventType\n\n@OptIn(ExperimentalDecomposeApi::class)\nfun main() {\n    val lifecycle = LifecycleRegistry()\n\n    val root =\n        DefaultRootComponent(\n            // Pass the LifecycleRegistry to the context\n            componentContext = DefaultComponentContext(lifecycle = lifecycle),\n            ... // Other dependencies here\n        )\n\n    // Attach the LifecycleRegistry to document\n    lifecycle.attachToDocument()\n\n    // Render the UI\n    createRoot(document.getElementById(\"app\")!!).render(\n        RootContent.create {\n            component = root\n        }\n    )\n}\n\n// Attaches the LifecycleRegistry to the document\nprivate fun LifecycleRegistry.attachToDocument() {\n    fun onVisibilityChanged() {\n        if (document.visibilityState == DocumentVisibilityState.visible) {\n            resume()\n        } else {\n            stop()\n        }\n    }\n\n    onVisibilityChanged()\n\n    document.addEventListener(type = EventType(\"visibilitychange\"), callback = { onVisibilityChanged() })\n}\n</code></pre>"},{"location":"getting-started/quick-start/#other-platforms-and-ui-frameworks","title":"Other platforms and UI frameworks","text":"<p>Please refer to samples for integrations with other platforms and UI frameworks. </p>"},{"location":"navigation/overview/","title":"Navigation overview","text":"<p>Decompose provides the ability to create permanent child components using the <code>childStack</code> extension function. But if you need to dynamically switch child components, then navigation comes in handy.</p> <p>Currently, Decompose provides several predefined navigation models:</p> <ul> <li>Child Stack - if you need to organize child components in a stack and navigate between them.</li> <li>Child Slot - if you need to activate-dismiss one child component at a time.</li> <li>Child Pages - if you need to organize child components in a list with one selected component.</li> <li>Child Panels - if you need to organize child components in a multi-pane mode with dynamic switching.</li> <li>Child Items - if you need an arbitrary list of child components, e.g., a lazy list.</li> </ul> <p>If none of this fit your needs, Decompose provides Generic Navigation that can be used to create your own custom navigation models. It offers a flexible API and allows you to create almost any kind of navigation.</p> <p>It is possible to have more than one navigation model in a parent component. Make sure that you supplied different keys (the <code>key</code> argument) if you have two or more navigation models of the same kind (e.g. you have two <code>Child Stacks</code> in one parent component).</p>"},{"location":"navigation/overview/#component-configurations-and-child-factories","title":"Component configurations and child factories","text":"<p>The term <code>Configuration</code> is widely used in Decompose navigation. A configuration is a persistent class that represents a child component and contains all its arguments (not dependencies). Decompose automatically persists child configurations using StateKeeper, so child components are automatically recreated on events like Android configuration changes, process death, etc.</p> <p>Usually, you initialize a navigation by supplying a child factory function to Decompose. The function accepts a child configuration and <code>ComponentContext</code> and returns a new instance of the corresponding child component - <code>(Config, ComponentContext) -&gt; Child</code>. When you need to navigate, you call a navigation method and pass a configuration there. Decompose automatically creates and manages a ComponentContext for every child component, and calls the provided factory function when a new instance of a child component is required. This is where you should instantiate child components and supply dependencies, the configuration only provides persistent arguments and is used to distinguish which component to create. </p>"},{"location":"navigation/overview/#configuration-requirements","title":"Configuration requirements","text":"<p>Configurations must meet the following requirements:</p> <ol> <li>Be immutable</li> <li>Correctly implement <code>equals()</code> and <code>hashCode()</code> methods</li> <li>Implement <code>Parcelable</code> interface (or be <code>@Serializable</code> starting with <code>v1.3.0-alpha01</code>)</li> </ol> <p>Different kinds of navigation may have additional requirements for configurations. It's recommended to define configurations as <code>data class</code>, and use only <code>val</code> properties and immutable data structures.</p>"},{"location":"navigation/overview/#configurations-are-serializable","title":"Configurations are <code>@Serializable</code>","text":"<p>Configurations can be persisted via Android's saved state, thus allowing the navigation state to be restored after configuration changes or process death. Decompose relies on kotlinx-serialization library for persistence. Each configuration class should be annotated as <code>@Serializable</code>, or a custom serializer should be implemented manually.</p> <p>Please make sure you setup <code>kotlinx-serialization</code> correctly and applied the plugin.</p> <p>Warning</p> <p>On Android the amount of data that can be preserved is limited. Please mind the size of configurations.</p>"},{"location":"navigation/overview/#navigation-and-the-main-thread","title":"Navigation and the main thread","text":"<p>The navigation API is thread-safe, technically the navigation can be performed on any thread. However, it's strongly recommended to initialize and perform the navigation on the Main thread. Since the navigation is performed synchronously, Decompose instantiates components and calls lifecycle callbacks on the current thread. Navigating on a background thread may cause unexpected behaviour.</p> <p>Warning</p> <p>Always initialize and perform the navigation on the Main thread.</p> <p>Decompose tries its best to detect when the navigation is performed on a non-main thread. When it happens, Decompose calls the special error handler - <code>onDecomposeError</code>. By default, it prints the exception to logs,  however you can override the default behaviour by providing your own handler.</p>"},{"location":"navigation/web-navigation/","title":"Web Browser Navigation","text":"<p>Warning</p> <p>This API is experimental, available since version <code>3.3.0-alpha01</code>.</p> <p>The Web Navigation API is a successor of the old Web Browser History API. It is a more flexible and powerful tool for managing browser URLs and history in a web application. The API is designed to work with different navigation models and provides a way to synchronize the browser URL and history with the navigation state. Currently, the following navigation models are supported:</p> <ul> <li>Child Stack</li> <li>Child Pages</li> <li>Child Panels</li> </ul> <p>The <code>Child Slot</code> navigation model is currently not supported. It will likely require additional API changes, might be implemented in the future.</p>"},{"location":"navigation/web-navigation/#webnavigation-and-webnavigationowner-interfaces","title":"WebNavigation and WebNavigationOwner interfaces","text":"<p>The API consists of two main interfaces:</p> <ul> <li>WebNavigation - A two-way navigation controller for Web browsers that connects a navigation model (e.g. <code>Child Stack</code>) with the browser's navigation history.</li> <li>WebNavigationOwner - An interface that represents a holder of <code>WebNavigation</code>, typically implemented by a Decompose component.</li> </ul> <p>You don't need to implement the <code>WebNavigation</code> interface directly. Instead, you should implement the <code>WebNavigationOwner</code> interface in your component using one of the provided functions available for each supported navigation model:</p> <ul> <li>childStackWebNavigation - For <code>Child Stack</code> navigation model.</li> <li>childPagesWebNavigation - For <code>Child Pages</code> navigation model.</li> <li>childPanelsWebNavigation - For <code>Child Panels</code> navigation model.</li> </ul> <p>Only one instance of the <code>WebNavigation</code> controller is allowed per component. The new API also supports nested navigation, there can only be up to one (zero or one) child <code>WebNavigationOwner</code> at a time.</p>"},{"location":"navigation/web-navigation/#enabling-the-web-navigation","title":"Enabling the Web Navigation","text":"<p>To enable the Web Navigation, just use the <code>withWebHistory {}</code> function available for <code>js</code> (link) and <code>wasmJs</code> (link) targets separately. The function provides two parameters: the current URL and an instance of <code>StateKeeper</code>. The URL should typically be used as a deep link to initialize the navigation state. The <code>StateKeeper</code> automatically saves and restores the navigation state on page reloads, it should be used to create the root <code>ComponentContext</code>.</p> <p>Once the Web Navigation is enabled, the browser URL and history will be automatically synchronized with the navigation state. The browser history automatically follows the navigation state changes, and the navigation is automatically performed following the browser history changes.</p>"},{"location":"navigation/web-navigation/#configuring-the-application","title":"Configuring the application","text":"<p>Using Web Navigation in a single page application requires additional configuration - a catch-all strategy to return the same html resource for all paths. This strategy will be different for different server configurations.</p>"},{"location":"navigation/web-navigation/#development-configuration","title":"Development configuration","text":"<p>The Kotlin/JS <code>browser</code> target uses webpack-dev-server as a local development server. It can be configured to use the same <code>index.html</code> file (or your primary html file) for all paths, by setting the devServer.historyApiFallback flag. The Gradle DSL for Kotlin webpack currently does not support the <code>historyApiFallback</code> flag, so a special configuration file should be used instead.</p> <p>First, create a directory named <code>webpack.config.d</code> in the JS app module's directory. Then create a new file named <code>devServerConfig.js</code> inside that directory. Finally, put the following content to the file:</p> <pre><code>// &lt;js app module&gt;/webpack.config.d/devServerConfig.js\n\nconfig.devServer = {\n  ...config.devServer, // Merge with other devServer settings\n  \"historyApiFallback\": true\n};\n</code></pre>"},{"location":"navigation/web-navigation/#web-navigation-with-child-stack","title":"Web Navigation with Child Stack","text":"Component interface<pre><code>import com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.webhistory.WebNavigationOwner\nimport com.arkivanov.decompose.value.Value\n\ninterface MyStackComponent : WebNavigationOwner {\n    val stack: Value&lt;ChildStack&lt;*, Child&gt;&gt;\n\n    sealed class Child {\n        // Omitted code\n    }\n}\n</code></pre> Component implementation<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport com.arkivanov.decompose.router.stack.childStackWebNavigation\nimport com.arkivanov.decompose.router.webhistory.WebNavigation\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\nclass DefaultMyStackComponent(\n    componentContext: ComponentContext,\n    deepLinkUrl: String?, // Or your favourite data structure, like Uri, etc.\n) : MyStackComponent, ComponentContext by componentContext {\n\n    private val nav = StackNavigation&lt;Config&gt;()\n\n    private val _stack: Value&lt;ChildStack&lt;Config, MyStackComponent.Child&gt;&gt; =\n        childStack(\n            source = nav,\n            serializer = Config.serializer(),\n            initialStack = { TODO(\"Use the deepLinkUrl parameter to initialize the stack\") },\n            childFactory = { ... },\n        )\n\n    override val stack: Value&lt;ChildStack&lt;*, MyStackComponent.Child&gt;&gt; = _stack\n\n    override val webNavigation: WebNavigation&lt;*&gt; =\n        childStackWebNavigation(\n            navigator = nav,\n            stack = _stack,\n            serializer = Config.serializer(),\n            pathMapper = { child -&gt; TODO(\"Return a path for the child\") }, // Optional\n            parametersMapper = { child -&gt; TODO(\"Return a Map with parameters for the child\") }, // Optional\n            childSelector = { child -&gt; TODO(\"Return a WebNavigationOwner for the child\") }, // Optional\n        )\n\n    @Serializable\n    private sealed interface Config {\n        // Omitted code\n    }\n}\n</code></pre>"},{"location":"navigation/web-navigation/#web-navigation-with-child-pages","title":"Web Navigation with Child Pages","text":"Component interface<pre><code>import com.arkivanov.decompose.router.pages.ChildPages\nimport com.arkivanov.decompose.router.webhistory.WebNavigationOwner\nimport com.arkivanov.decompose.value.Value\n\ninterface MyPagesComponent : WebNavigationOwner {\n    val pages: Value&lt;ChildPages&lt;*, ...&gt;&gt;\n}\n</code></pre> Component implementation<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.pages.ChildPages\nimport com.arkivanov.decompose.router.pages.PagesNavigation\nimport com.arkivanov.decompose.router.pages.childPages\nimport com.arkivanov.decompose.router.pages.childPagesWebNavigation\nimport com.arkivanov.decompose.router.webhistory.WebNavigation\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\nclass DefaultMyPagesComponent(\n    componentContext: ComponentContext,\n    deepLinkUrl: String?, // Or your favourite data structure, like Uri, etc.\n) : MyPagesComponent, ComponentContext by componentContext {\n\n    private val nav = PagesNavigation&lt;Config&gt;()\n\n    private val _pages: Value&lt;ChildPages&lt;Config, ...&gt;&gt; =\n        childPages(\n            source = nav,\n            serializer = Config.serializer(),\n            initialPages = { TODO(\"Use the deepLinkUrl parameter to initialize the navigation\") },\n            childFactory = { ... },\n        )\n\n    override val pages: Value&lt;ChildPages&lt;*, ...&gt;&gt; = _pages\n\n    override val webNavigation: WebNavigation&lt;*&gt; =\n        childPagesWebNavigation(\n            navigator = nav,\n            pages = _pages,\n            serializer = Config.serializer(),\n            pathMapper = { pages -&gt; TODO(\"Return a path for the navigation state\") }, // Optional\n            parametersMapper = { pages -&gt; TODO(\"Return a Map with parameters for the navigation state\") }, // Optional\n            childSelector = { child -&gt; TODO(\"Return a WebNavigationOwner for the child\") }, // Optional\n        )\n\n    @Serializable\n    private data class Config(...)\n}\n</code></pre>"},{"location":"navigation/web-navigation/#web-navigation-with-child-panels","title":"Web Navigation with Child Panels","text":"Component interface<pre><code>import com.arkivanov.decompose.router.panels.ChildPanels\nimport com.arkivanov.decompose.router.webhistory.WebNavigationOwner\nimport com.arkivanov.decompose.value.Value\n\ninterface MyPanelsComponent : WebNavigationOwner {\n    val panels: Value&lt;ChildPanels&lt;...&gt;&gt;\n}\n</code></pre> Component implementation<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.panels.ChildPanels\nimport com.arkivanov.decompose.router.panels.PanelsNavigation\nimport com.arkivanov.decompose.router.panels.childPanels\nimport com.arkivanov.decompose.router.panels.childPanelsWebNavigation\nimport com.arkivanov.decompose.router.webhistory.WebNavigation\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\nclass DefaultMyPanelsComponent(\n    componentContext: ComponentContext,\n    deepLinkUrl: String?, // Or your favourite data structure, like Uri, etc.\n) : MyPanelsComponent, ComponentContext by componentContext {\n\n    private val nav = PanelsNavigation&lt;MainConfig, DetailsConfig, Nothing&gt;()\n\n    private val _panels: Value&lt;ChildPanels&lt;...&gt;&gt; =\n        childPanels(\n            source = nav,\n            serializers = MainConfig.serializer() to DetailsConfig.serializer(),\n            initialPanels = { TODO(\"Use the deepLinkUrl parameter to initialize the navigation\") },\n            mainFactory = { ... },\n            detailsFactory = { ... },\n        )\n\n    override val panels: Value&lt;ChildPanels&lt;...&gt;&gt; = _panels\n\n    override val webNavigation: WebNavigation&lt;*&gt; =\n        childPanelsWebNavigation(\n            navigator = nav,\n            panels = _panels,\n            serializers = MainConfig.serializer() to DetailsConfig.serializer(),\n            pathMapper = { panels -&gt; TODO(\"Return a path for the navigation state\") }, // Optional\n            parametersMapper = { panels -&gt; TODO(\"Return a Map with parameters for the navigation state\") }, // Optional\n            childSelector = { panels -&gt; TODO(\"Return a WebNavigationOwner for the navigation state\") }, // Optional\n        )\n\n    @Serializable\n    private data class MainConfig(...)\n\n    @Serializable\n    private data class DetailsConfig(...)\n}\n</code></pre>"},{"location":"navigation/web-navigation/#example","title":"Example","text":"<p>Please refer to the main sample for a complete example of using the Web Navigation API.</p>"},{"location":"navigation/children/overview/","title":"Generic Navigation","text":"<p>The <code>Generic Navigation</code> can be used to create custom navigation models, when none of the predefined models fit your needs. It offers a flexible API and allows you to create almost any kind of navigation. Please check out Child Stack and Child Slot before using the <code>Generic Navigation</code>.</p> <p>The API is based around NavState and ChildNavState interfaces that should be implemented by clients. <code>NavState</code> represents a persistent state of the navigation. It also holds a navigation state for each child - <code>ChildNavState</code>. Both <code>NavState</code> and <code>ChildNavState</code> must be immutable, and correctly implement <code>equals</code> and <code>hashCode</code> methods (or just be data objects/classes). There must be no duplicated (by equality) <code>ChildNavState.configuration</code> within a <code>NavState</code>.</p> <p>The navigation is performed by transforming the current <code>NavState</code> to a new one. The <code>Generic Navigation</code> implementation calculates diffs between the old list of <code>ChildNavState</code> and the new one, and manipulates child components as needed.</p>"},{"location":"navigation/children/overview/#childnavstate","title":"ChildNavState","text":"<p><code>ChildNavState</code> represents a state of a child component. It holds a <code>Configuration</code> that works as a key of the child component, and a <code>Status</code> that represents the required lifecycle status of the child component. As mentioned earlier, the <code>Configuration</code> must be unique within the <code>NavState</code>, unless <code>DecomposeExperimentFlags.duplicateConfigurationsEnabled</code> flag is enabled.</p> <p>The <code>Status</code> can be one of the following:</p> <ul> <li> <p><code>RESUMED</code> - The child component is instantiated and its maximum lifecycle state is <code>RESUMED</code>, depending on the parent's lifecycle state. A <code>RESUMED</code> component can handle back button presses.</p> </li> <li> <p><code>STARTED</code> - The child component is instantiated and its maximum lifecycle state is <code>STARTED</code>, depending on the parent's lifecycle state. A <code>STARTED</code> component can handle back button presses.</p> </li> <li> <p><code>CREATED</code> - The child component is instantiated and its maximum lifecycle state is <code>CREATED</code>, depending on the parent's lifecycle state. A <code>CREATED</code> component cannot handle back button presses.</p> </li> <li> <p><code>DESTROYED</code> - The child component is destroyed but still managed, e.g. it's state may be saved and restored later. The state of the component is saved when it switches from any status to <code>DESTROYED</code>.</p> </li> </ul> <p>If you want to completely remove the child component from the navigation, you should remove its <code>ChildNavState</code> from the <code>NavState</code> altogether.</p> <p>The SimpleChildNavState class implements the <code>ChildNavState</code> interfaces. It can be used in simple cases when custom implementation is not required.</p>"},{"location":"navigation/children/overview/#using-the-generic-navigation","title":"Using the Generic Navigation","text":"<p>Using the <code>Generic Navigation</code> is pretty similar to any other navigation model, there is ComponentContext.children(...) extension function.</p>"},{"location":"navigation/children/overview/#saving-and-restoring-the-navigation-state-manually","title":"Saving and restoring the navigation state manually","text":"<pre><code>fun &lt;C : Any, T : Any, E : Any, N : NavState&lt;C&gt;, S : Any&gt; ComponentContext.children(\n    source: NavigationSource&lt;E&gt;,\n    key: String,\n    initialState: () -&gt; N,\n    saveState: (state: N) -&gt; SerializableContainer?,\n    restoreState: (container: SerializableContainer) -&gt; N?,\n    navTransformer: (state: N, event: E) -&gt; N,\n    stateMapper: (state: N, children: List&lt;Child&lt;C, T&gt;&gt;) -&gt; S,\n    onStateChanged: (newState: N, oldState: N?) -&gt; Unit = { _, _ -&gt; },\n    onEventComplete: (event: E, newState: N, oldState: N) -&gt; Unit = { _, _, _ -&gt; },\n    backTransformer: (state: N) -&gt; (() -&gt; N)? = { null },\n    childFactory: (configuration: C, componentContext: ComponentContext) -&gt; T,\n): Value&lt;S&gt;\n</code></pre> <p>The <code>children</code> function has the following type parameters:</p> <ul> <li><code>C</code> - a type of component configurations.</li> <li><code>T</code> - a type of components.</li> <li><code>E</code> - a type of navigation events.</li> <li><code>N</code> - a type of navigation state, must implement <code>NavState</code> interface.</li> <li><code>S</code> - a type of the resulting children state.</li> </ul> <p>The <code>children</code> function accepts the following arguments:</p> <ul> <li><code>source: NavigationSource&lt;E&gt;</code> - an observable source of navigation events, the <code>Generic Navigation</code> subscribes to the source and performs the navigation. The SimpleNavigation class can be used in simple cases when custom implementation is not required.</li> <li><code>key: String</code> - a key of the navigation, must be unique if there are multiple <code>children</code> used in the same component.</li> <li><code>initialState: () -&gt; N</code> - an initial navigation state that should be used if there is no previously saved state.</li> <li><code>saveState: (state: N) -&gt; SerializableContainer</code> - a function that saves the provided navigation state into <code>SerializableContainer</code>, called when the hosting component goes to background.</li> <li><code>restoreState: (container: SerializableContainer) -&gt; N</code> - a function that restores the navigation state from the provided <code>SerializableContainer</code>. The restored navigation state must have the same amount of child configurations and in the same order. The restored child <code>Statuses</code> can be any, e.g. a previously active child may become destroyed, etc.</li> <li><code>navTransformer: (state: N, event: E) -&gt; N</code> - a function that transforms the current navigation state to a new one using the provided navigation event. The implementation diffs both navigation states and manipulates child components as needed.</li> <li><code>stateMapper: (state: N, children: List&lt;Child&lt;C, T&gt;&gt;) -&gt; S</code> - combines the provided navigation state and list of child components to a resulting custom state.</li> <li><code>onStateChanged: (newState: N, oldState: N?) -&gt; Unit</code> - called every time the navigation state changes, <code>oldState</code> is <code>null</code> when called first time during initialisation. </li> <li><code>onEventComplete: (event: E, newState: N, oldState: N) -&gt; Unit</code> - called when a navigation event is processed and the navigation completed.</li> <li><code>backTransformer: (state: N) -&gt; (() -&gt; N)?</code> - a function that checks the provided navigation state, and either returns another function transforming the navigation state to a new one, or <code>null</code> if back button handling should be disabled. Called during the initialisation and after each navigation event.</li> <li><code>childFactory: (configuration: C, componentContext: ComponentContext) -&gt; T</code> - childFactory a factory function that creates new child component instances.</li> </ul> <p>The <code>children</code> function returns an observable <code>Value</code> of the resulting children state.</p>"},{"location":"navigation/children/overview/#saving-and-restoring-the-navigation-state-automatically","title":"Saving and restoring the navigation state automatically","text":"<pre><code>fun &lt;C : Any, T : Any, E : Any, N : NavState&lt;C&gt;, S : Any&gt; ComponentContext.children(\n    source: NavigationSource&lt;E&gt;,\n    stateSerializer: KSerializer&lt;N&gt;?,\n    initialState: () -&gt; N,\n    key: String,\n    navTransformer: (state: N, event: E) -&gt; N,\n    stateMapper: (state: N, children: List&lt;Child&lt;C, T&gt;&gt;) -&gt; S,\n    onStateChanged: (newState: N, oldState: N?) -&gt; Unit = { _, _ -&gt; },\n    onEventComplete: (event: E, newState: N, oldState: N) -&gt; Unit = { _, _, _ -&gt; },\n    backTransformer: (state: N) -&gt; (() -&gt; N)? = { null },\n    childFactory: (configuration: C, componentContext: ComponentContext) -&gt; T,\n): Value&lt;S&gt;\n</code></pre> <p>This is a convenience function similar to the one described above. It accepts an optional <code>KSerializer&lt;N&gt;</code> argument, so that the navigation state is saved and restored automatically. The navigation state is never saved or restored if the serializer is not provided.</p>"},{"location":"navigation/children/overview/#examples","title":"Examples","text":""},{"location":"navigation/children/overview/#a-stack-that-can-be-empty","title":"A stack that can be empty","text":"<p>Child Stack provided by Decompose can not be empty. Here is an example of using the Generic Navigation for creating an API for a stack that can be empty.</p> <pre><code>import com.arkivanov.decompose.Child\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.children.ChildNavState\nimport com.arkivanov.decompose.router.children.ChildNavState.Status\nimport com.arkivanov.decompose.router.children.NavState\nimport com.arkivanov.decompose.router.children.NavigationSource\nimport com.arkivanov.decompose.router.children.SimpleChildNavState\nimport com.arkivanov.decompose.router.children.children\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.Transient\n\ndata class Stack&lt;out C : Any, out T : Any&gt;(\n    val items: List&lt;Child.Created&lt;C, T&gt;&gt;,\n)\n\ntypealias StackNavEvent&lt;C&gt; = (List&lt;C&gt;) -&gt; List&lt;C&gt;\n\nfun &lt;C : Any, T : Any&gt; ComponentContext.stack(\n    source: NavigationSource&lt;StackNavEvent&lt;C&gt;&gt;,\n    serializer: KSerializer&lt;C&gt;,\n    initialStack: () -&gt; List&lt;C&gt; = ::emptyList,\n    key: String = \"Stack\",\n    childFactory: (configuration: C, componentContext: ComponentContext) -&gt; T,\n): Value&lt;Stack&lt;C, T&gt;&gt; =\n    children(\n        source = source,\n        stateSerializer = StackNavState.serializer(serializer),\n        initialState = { StackNavState(initialStack()) },\n        key = key,\n        navTransformer = { state, event -&gt; StackNavState(event(state.items)) },\n        stateMapper = { _, children -&gt; Stack(children as List&lt;Child.Created&lt;C, T&gt;&gt;) },\n        backTransformer = { state -&gt;\n            state.items.takeUnless(List&lt;*&gt;::isEmpty)?.let { items -&gt;\n                { StackNavState(items.dropLast(1)) }\n            }\n        },\n        childFactory = childFactory,\n    )\n\n@Serializable\nprivate data class StackNavState&lt;out C : Any&gt;(\n    val items: List&lt;C&gt;,\n) : NavState&lt;C&gt; {\n    @Transient\n    override val children: List&lt;ChildNavState&lt;C&gt;&gt; =\n        items.mapIndexed { index, config -&gt;\n            SimpleChildNavState(\n                configuration = config,\n                status = if (index == items.lastIndex) Status.RESUMED else Status.CREATED,\n            )\n        }\n}\n</code></pre> <p>And here is the usage example.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.children.SimpleNavigation\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\nclass PhotoComponent(url: String) {\n    // Some code here\n}\n\ninterface GalleryComponent {\n    val stack: Value&lt;Stack&lt;*, PhotoComponent&gt;&gt;\n}\n\nclass DefaultGalleryComponent(\n    componentContext: ComponentContext,\n) : GalleryComponent, ComponentContext by componentContext {\n\n    private val nav = SimpleNavigation&lt;StackNavEvent&lt;Config&gt;&gt;()\n\n    override val stack: Value&lt;Stack&lt;*, PhotoComponent&gt;&gt; =\n        stack(\n            source = nav,\n            serializer = Config.serializer(),\n            childFactory = { config, ctx -&gt; PhotoComponent(url = config.url) },\n        )\n\n    private fun pushPhoto(url: String) {\n        nav.navigate { it + Config(url) }\n    }\n\n    private fun popPhoto() {\n        nav.navigate { it.dropLast(1) }\n    }\n\n    @Serializable\n    private data class Config(val url: String)\n}\n</code></pre>"},{"location":"navigation/children/overview/#more-samples","title":"More samples","text":"<p>All existing navigation models (like Child Stack) are implemented using the <code>Generic Navigation</code>. Please refer to their source code for implementation details.</p>"},{"location":"navigation/children/overview/#sample-project","title":"Sample project","text":"<p>See the sample project has the CustomNavigationComponent, which demonstrates how to use the <code>Generic Navigation</code>.</p> <p></p>"},{"location":"navigation/items/navigation/","title":"Navigation with Child Items","text":""},{"location":"navigation/items/navigation/#the-itemsnavigator","title":"The ItemsNavigator","text":"<p>All navigation in <code>Child Items</code> is performed using the  <code>ItemsNavigator</code> interface, which is extended by the <code>ItemsNavigation</code> interface.</p> <p><code>ItemsNavigator</code> contains the <code>navigate</code> method with the following arguments:</p> <ul> <li><code>transformer</code> - converts the current <code>Items</code> state to a new one.</li> <li><code>onComplete</code> - called when navigation is finished.</li> </ul> <p>There is also <code>navigate</code> extension function without the <code>onComplete</code> callback, for convenience.</p> Creating the navigation<pre><code>// In your component class\nval navigation = ItemsNavigation&lt;Configuration&gt;()\n</code></pre>"},{"location":"navigation/items/navigation/#the-navigation-process","title":"The navigation process","text":"<p>During the navigation process, the <code>Child Items</code> navigation model compares the new state with the previous one. It ensures that all deactivated or removed components are destroyed, and updates lifecycles of the active components to match the new state.</p> <p>The <code>Child Items</code> navigation model usually performs the navigation synchronously, which means that by the time the <code>navigate</code> method returns, the navigation is finished and all component lifecycles are moved into required states. However, the navigation is performed asynchronously in case of recursive invocations - e.g. <code>setActiveItems</code> is called from <code>onCreate</code> lifecycle callback of a component being activated. All recursive invocations are queued and performed one by one once the current navigation is finished.</p>"},{"location":"navigation/items/navigation/#itemsnavigator-extension-functions","title":"ItemsNavigator extension functions","text":"<p>There are <code>ItemsNavigator</code> extension functions to simplify the navigation. Some of which were already used in the Child Items Overview example.</p>"},{"location":"navigation/items/navigation/#setitemstransformer","title":"setItems(transformer)","text":"<p>Replaces the items with the provided list using a transformer function.</p> <p>Illustration</p> Before<pre><code>[Item1:DESTROYED, Item2:STARTED, Item3:RESUMED]\n</code></pre> <pre><code>navigation.setItems { items -&gt; items + Item4 - Item1 }\n</code></pre> After<pre><code>[Item2:STARTED, Item3:RESUMED, Item4:DESTROYED]\n</code></pre>"},{"location":"navigation/items/navigation/#setactiveitemstransformer","title":"setActiveItems(transformer)","text":"<p>Sets the currently instantiated (active) items with the provided lifecycle states using a transformer function.</p> <p>Illustration</p> Before<pre><code>[Item1:DESTROYED, Item2:STARTED, Item3:RESUMED]\n</code></pre> <pre><code>navigation.setActiveItems { activeItems -&gt;\n    activeItems + (Item1 to ActiveLifecycleState.RESUMED) - Item3\n}\n</code></pre> After<pre><code>[Item1:RESUMED, Item2:STARTED, Item3:DESTROYED]\n</code></pre>"},{"location":"navigation/items/overview/","title":"Child Items overview","text":""},{"location":"navigation/items/overview/#the-child-items","title":"The Child Items","text":"<p><code>Child Items</code> is a navigation model for managing a list of components with flexible lifecycle states. The list can be empty.</p> <p>Warning</p> <p>This navigation model is experimental and is available since version <code>3.4.0-alpha02</code>, the API is subject to change.</p> <p>Unlike other navigation models, <code>Child Items</code> allows you to have multiple active components with different lifecycle states at the same time. You can decide which components are active and what their lifecycle states are. A typical use case is a lazy list or grid where component lifecycles are automatically updated according to the current viewport.</p> <p>It is possible to have more than one <code>Child Items</code> navigation model in a component, nested navigation is also supported.</p> <p>The <code>Child Items</code> navigation model consists of three main entities:</p> <ul> <li>Items - represents a state of the <code>Child Items</code> navigation model. The navigation is performed by creating a new navigation state from the previous one.<ul> <li><code>Items#items</code> - the list of child configurations, can be empty, must be unique.</li> <li><code>Items#activeItems</code> - a map of lifecycle states of the instantiated (active) components. Child components whose configurations are not present in this map are destroyed. Configurations in the map should also be present in the <code>items</code> list, otherwise the behavior is undefined.</li> </ul> </li> <li>ChildItems - a simple data class that stores a list component configurations, as well as a map of active components with their lifecycle states.<ul> <li><code>ChildItems#items</code> - the list of child configurations, can be empty.</li> <li><code>ChildItems#activeItems</code> - a map of instantiated child components and their lifecycle states.</li> </ul> </li> <li>ItemsNavigation - an interface that accepts navigation commands and forwards them to all subscribed observers.</li> </ul>"},{"location":"navigation/items/overview/#component-configurations","title":"Component Configurations","text":"<p>Similarly to other navigation models, each component created and managed by the <code>Child Items</code> has a configuration, please read the documentation about child configurations.</p> <p><code>Child Items</code> adds one additional requirement for child configurations:</p> <ul> <li>Configurations must be unique (by equality) within <code>Child Items</code>.</li> </ul>"},{"location":"navigation/items/overview/#the-experimental-duplicate-configurations-mode","title":"The experimental Duplicate Configurations mode","text":"<p>Unlike other navigation models, the <code>Child Items</code> navigation model doesn't support the Duplicate Configurations mode. <code>IllegalStateException</code> is thrown if duplicate configurations are detected, regardless of the <code>DecomposeExperimentFlags.duplicateConfigurationsEnabled</code> flag.</p>"},{"location":"navigation/items/overview/#initializing-child-items","title":"Initializing Child Items","text":"<p>There are three steps to initialize <code>Child Items</code>:</p> <ul> <li>Create a new instance of <code>ItemsNavigation</code> and assign it to a variable or a property.</li> <li>Initialize the <code>Child Items</code> navigation model using the <code>ComponentContext#childItems</code> extension function and pass <code>ItemsNavigation</code> into it along with other arguments.</li> <li>The <code>childItems</code> function returns <code>LazyChildItems</code> that can be observed and manipulated in the UI. Assign the returned <code>LazyChildItems</code> to another property or a variable.</li> </ul>"},{"location":"navigation/items/overview/#example","title":"Example","text":"<p>Here is a very basic example of a flexible navigation with multiple active components:</p> ItemComponent<pre><code>import com.arkivanov.decompose.ComponentContext\nimport kotlinx.serialization.Serializable\n\ninterface ItemComponent {\n    val item: Item\n}\n\n@Serializable // kotlinx-serialization plugin must be applied\ndata class Item(val id: Int, val data: String)\n\nclass DefaultItemComponent(\n    componentContext: ComponentContext,\n    override val item: Item,\n) : ItemComponent, ComponentContext by componentContext\n</code></pre> ItemsComponent<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.items.Items\nimport com.arkivanov.decompose.router.items.ItemsNavigation\nimport com.arkivanov.decompose.router.items.LazyChildItems\nimport com.arkivanov.decompose.router.items.childItems\nimport com.arkivanov.decompose.router.items.setItems\n\ninterface ItemsComponent {\n    val items: LazyChildItems&lt;Item, ItemComponent&gt;\n}\n\nclass DefaultItemsComponent(\n    componentContext: ComponentContext,\n) : ItemsComponent, ComponentContext by componentContext {\n\n    private val navigation = ItemsNavigation&lt;Item&gt;()\n\n    override val items: LazyChildItems&lt;Item, ItemComponent&gt; =\n        childItems(\n            source = navigation,\n            serializer = Item.serializer(), // Or null to disable navigation state saving\n            initialItems = {\n                Items(\n                    items = List(100) { index -&gt;\n                        Item(id = index, data = \"Item $index\")\n                    },\n                )\n            },\n        ) { item, childComponentContext -&gt;\n            DefaultItemComponent(\n                componentContext = childComponentContext,\n                item = item,\n            )\n        }\n\n    private fun addMoreItems(newItems: List&lt;Item&gt;) {\n        navigation.setItems { items -&gt; items + newItems }\n    }\n}\n</code></pre>"},{"location":"navigation/items/overview/#screen-recreation-and-process-death-on-not-only-android","title":"Screen recreation and process death on (not only) Android","text":"<p><code>Child Items</code> automatically preserves the state when a configuration change or process death occurs. To disable state preservation completely, pass <code>serializer = null</code> argument. When navigation state saving is disabled, the state is reset to the initial value when recreated.</p> <p>If the list is big, it might be a good idea to avoid saving the state over process death (i.e., serializing it to disk and potentially exceeding the Bundle size on Android). At the same time, it's good to still keep the state over configuration changes on Android. In this case, pass <code>stateSaver = transientNavStateSaver()</code> argument instead of the <code>serializer</code> argument.</p>"},{"location":"navigation/items/overview/#multiple-child-items-in-a-component","title":"Multiple Child Items in a component","text":"<p>When multiple <code>Child Items</code> are used in one component, each such <code>Child Items</code> must have a unique <code>key</code> argument associated. The keys are required to be unique only within the hosting component, so it is ok for different components to have <code>Child Items</code> with same keys. An exception will be thrown if multiple <code>Child Items</code> with the same key are detected in a component.</p>"},{"location":"navigation/pages/navigation/","title":"Navigation with Child Pages","text":""},{"location":"navigation/pages/navigation/#the-pagesnavigator","title":"The PagesNavigator","text":"<p>All navigation in <code>Child Pages</code> is performed using the <code>PagesNavigator</code> interface, which is extended by the <code>PagesNavigation</code> interface.</p> <p><code>PagesNavigator</code> contains the <code>navigate</code> method with the following arguments:</p> <ul> <li><code>transformer</code> - converts the current navigation state (<code>Pages</code>) into a new one.</li> <li><code>onComplete</code> - called when navigation is finished.</li> </ul> <p>There is also <code>navigate</code> extension function without the <code>onComplete</code> callback, for convenience.</p> Creating the navigation<pre><code>// In your component class\nval navigation = PagesNavigation&lt;Configuration&gt;()\n</code></pre>"},{"location":"navigation/pages/navigation/#the-navigation-process","title":"The navigation process","text":"<p>During the navigation process, the Child Pages navigation model compares the new [Pages] state with the previous one. The navigation model ensures that all removed components are destroyed, and updates lifecycles of the existing components to match the new state.</p> <p>The navigation is usually performed synchronously, which means that by the time the <code>navigate</code> method returns, the navigation is finished and all component lifecycles are moved into required states. However, the navigation is performed asynchronously in case of recursive invocations - e.g. <code>selectNext</code> is called from <code>onResume</code> lifecycle callback of a component being shown. All recursive invocations are queued and performed one by one once the current navigation is finished.</p>"},{"location":"navigation/pages/navigation/#pagesnavigator-extension-functions","title":"PagesNavigator extension functions","text":"<p>There are <code>PagesNavigator</code> extension functions to simplify the navigation. Some of which were already used in the Child Pages Overview example.</p>"},{"location":"navigation/pages/navigation/#selectnext","title":"selectNext","text":"<p>Selects the next component. If the currently selected component is the last one, then depending on the [circular] parameter, either nothing happens or the first component is selected.</p> <p>Illustration</p> Before<pre><code>1: [A, B*, C]\n2: [A, B, C*]\n3: [A, B, C*]\n</code></pre> <pre><code>1: navigation.selectNext()\n2: navigation.selectNext(circular = false)\n3: navigation.selectNext(circular = true)\n</code></pre> After<pre><code>1: [A, B, C*]\n2: [A, B, C*]\n3: [A*, B, C]\n</code></pre>"},{"location":"navigation/pages/navigation/#selectprev","title":"selectPrev","text":"<p>elects the previous component. If the currently selected component is the first one, then depending on the [circular] parameter, either nothing happens or the last component is selected.</p> <p>Illustration</p> Before<pre><code>1: [A, B*, C]\n2: [A*, B, C]\n3: [A*, B, C]\n</code></pre> <pre><code>1: navigation.selectPrev()\n2: navigation.selectPrev(circular = false)\n3: navigation.selectPrev(circular = true)\n</code></pre> After<pre><code>1: [A*, B, C]\n2: [A*, B, C]\n3: [A, B, C*]\n</code></pre>"},{"location":"navigation/pages/navigation/#selectfirst","title":"selectFirst","text":"<p>Selects the first component.</p> <p>Illustration</p> Before<pre><code>[A, B*, C]\n</code></pre> <pre><code>navigation.selectFirst()\n</code></pre> After<pre><code>[A*, B, C]\n</code></pre>"},{"location":"navigation/pages/navigation/#selectlast","title":"selectLast","text":"<p>Selects the last component.</p> <p>Illustration</p> Before<pre><code>[A, B*, C]\n</code></pre> <pre><code>navigation.selectLast()\n</code></pre> After<pre><code>[A, B, C*]\n</code></pre>"},{"location":"navigation/pages/navigation/#selectindex","title":"select(index)","text":"<p>Selects the component at the specified [index]. Throws [IllegalArgumentException] if the index is out of bounds.</p> <p>Illustration</p> Before<pre><code>[A*, B, C]\n</code></pre> <pre><code>navigation.select(2)\n</code></pre> After<pre><code>[A, B, C*]\n</code></pre>"},{"location":"navigation/pages/navigation/#clear","title":"clear","text":"<p>Clears the current [Pages] state, i.e. removes all components.</p> <p>Illustration</p> Before<pre><code>[A, B*, C]\n</code></pre> <pre><code>navigation.clear()\n</code></pre> After<pre><code>[]\n</code></pre>"},{"location":"navigation/pages/navigation/#setitems","title":"setItems","text":"<p>Note</p> <p>Available since version <code>3.4.0-alpha02</code>.</p> <p>Replaces the components with the provided list. The <code>selectedIndex</code> parameter is automatically coerced within the new list's range.</p> <p>Illustration 1</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.setItems { it + listOf(D) }\n</code></pre> After<pre><code>[A, B, C*, D]\n</code></pre> <p>Illustration 2</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.setItems { it - C }\n</code></pre> After<pre><code>[A, B*]\n</code></pre>"},{"location":"navigation/pages/overview/","title":"Child Pages overview","text":""},{"location":"navigation/pages/overview/#the-child-pages","title":"The Child Pages","text":"<p><code>Child Pages</code> is a navigation model for managing a list of components (pages) with one selected (active) component. The list can be empty.</p> <p>Similarly to <code>Child Stack</code>, each component has its own <code>Lifecycle</code>. By default, the currently selected page is <code>ACTIVE</code>, its two neighbours are <code>INACTIVE</code>, and the rest are <code>DESTROYED</code>. You can implement your own logic, for example with circular behaviour. </p> <p>It is possible to have more than one <code>Child Pages</code> navigation model in a component, nested navigation is also supported.</p> <p>The <code>Child Pages</code> navigation model consists of three main entities:</p> <ul> <li>Pages - represents a state of the <code>Child Pages</code> navigation model. The navigation is performed by creating a new navigation state from the previous one.<ul> <li><code>Pages#items</code> - the list of child configurations, must be unique, can be empty.</li> <li><code>Pages#selectedIndex</code> - index of the selected child configuration.</li> </ul> </li> <li>ChildPages - a simple data class that stores a list of components and their configurations, as well as the currently selected index.<ul> <li><code>ChildPages#items</code> - the list of child component, can be empty.</li> <li><code>ChildPages#selectedIndex</code> - the index of the currently selected child component. Must be within the range of <code>items</code> indices if <code>items</code> is not empty, otherwise can be any number.</li> </ul> </li> <li>PagesNavigation - an interface that accepts navigation commands and forwards them to all subscribed observers.</li> </ul>"},{"location":"navigation/pages/overview/#component-configurations","title":"Component Configurations","text":"<p>Similarly to <code>Child Stack</code>, each component created and managed by the <code>Child Pages</code> has a configuration, please read the documentation about child configurations.</p> <p><code>Child Pages</code> adds one additional requirement for child configurations:</p> <ul> <li>Configurations must be unique (by equality) within <code>Child Pages</code>.</li> </ul>"},{"location":"navigation/pages/overview/#the-experimental-duplicate-configurations-mode","title":"The experimental Duplicate Configurations mode","text":"<p>You can also try enabling the experimental Duplicate Configurations mode using the following flag:</p> <pre><code>DecomposeExperimentFlags.duplicateConfigurationsEnabled = true\n</code></pre> <p>This will allow having duplicate configurations in all navigation models. Please keep in mind that this feature is experimental.</p>"},{"location":"navigation/pages/overview/#initializing-child-pages","title":"Initializing Child Pages","text":"<p>There are three steps to initialize <code>Child Pages</code>:</p> <ul> <li>Create a new instance of <code>PagesNavigation</code> and assign it to a variable or a property.</li> <li>Initialize the <code>Child Pages</code> navigation model using the <code>ComponentContext#childPages</code> extension function and pass <code>PagesNavigation</code> into it along with other arguments.</li> <li>The <code>childPages</code> function returns <code>Value&lt;ChildPages&gt;</code> that can be observed in the UI. Assign the returned <code>Value</code> to another property or a variable.</li> </ul>"},{"location":"navigation/pages/overview/#displaying-pages-with-compose","title":"Displaying pages with Compose","text":"<p><code>Child Pages</code> state can be observed and displayed in Compose by using the <code>ChildPages</code> <code>Composable</code> function from the Compose extensions module provided by Decompose. Please see the related documentation for more information.</p>"},{"location":"navigation/pages/overview/#example","title":"Example","text":"<p>Here is a very basic example of a pager-like navigation:</p> PageComponent<pre><code>import com.arkivanov.decompose.ComponentContext\n\ninterface PageComponent {\n    val data: String\n}\n\nclass DefaultPageComponent(\n    componentContext: ComponentContext,\n    override val data: String,\n) : PageComponent, ComponentContext by componentContext\n</code></pre> PagesComponent<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.pages.ChildPages\nimport com.arkivanov.decompose.router.pages.Pages\nimport com.arkivanov.decompose.router.pages.PagesNavigation\nimport com.arkivanov.decompose.router.pages.childPages\nimport com.arkivanov.decompose.router.pages.select\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\ninterface PagesComponent {\n    val pages: Value&lt;ChildPages&lt;*, PageComponent&gt;&gt;\n\n    fun selectPage(index: Int)\n}\n\nclass DefaultPagesComponent(\n    componentContext: ComponentContext,\n) : PagesComponent, ComponentContext by componentContext {\n\n    private val navigation = PagesNavigation&lt;Config&gt;()\n\n    override val pages: Value&lt;ChildPages&lt;*, PageComponent&gt;&gt; =\n        childPages(\n            source = navigation,\n            serializer = Config.serializer(), // Or null to disable navigation state saving\n            initialPages = {\n                Pages(\n                    items = List(10) { index -&gt; Config(data = \"Item $index\") },\n                    selectedIndex = 0,\n                )\n            },\n        ) { config, childComponentContext -&gt;\n            DefaultPageComponent(\n                componentContext = childComponentContext,\n                data = config.data,\n            )\n        }\n\n    override fun selectPage(index: Int) {\n        navigation.select(index = index)\n    }\n\n    @Serializable // kotlinx-serialization plugin must be applied\n    private data class Config(val data: String)\n}\n</code></pre>"},{"location":"navigation/pages/overview/#screen-recreation-and-process-death-on-not-only-android","title":"Screen recreation and process death on (not only) Android","text":"<p><code>Child Pages</code> automatically preserves the state when a configuration change or process death occurs. To disable state preservation completely, pass <code>serializer = null</code> argument. When navigation state saving is disabled, the state is reset to the initial value when recreated.</p> <p>Components are created in their order. E.g. the first component in the list is created first, then the next component in the list is created, and so on. Components are destroyed in reverse order.</p>"},{"location":"navigation/pages/overview/#multiple-child-pages-in-a-component","title":"Multiple Child Pages in a component","text":"<p>When multiple <code>Child Pages</code> are used in one component, each such <code>Child Pages</code> must have a unique <code>key</code> argument associated. The keys are required to be unique only within the hosting component, so it is ok for different components to have <code>Child Pages</code> with same keys. An exception will be thrown if multiple <code>Child Pages</code> with the same key are detected in a component.</p>"},{"location":"navigation/panels/navigation/","title":"Navigation with Child Stack","text":""},{"location":"navigation/panels/navigation/#the-panelsnavigator","title":"The PanelsNavigator","text":"<p>All navigation in <code>Child Panels</code> is performed using the <code>PanelsNavigator</code> interface, which is extended by the <code>PanelsNavigation</code> interface.</p> <p><code>PanelsNavigator</code> contains the <code>navigate</code> method with the following arguments:</p> <ul> <li><code>transformer</code> - converts the current <code>Panels</code> state to a new one.</li> <li><code>onComplete</code> - called when navigation is finished.</li> </ul> <p>There is also <code>navigate</code> extension function without the <code>onComplete</code> callback, for convenience.</p> Creating the navigation<pre><code>// In your component class\nval navigation = PanelsNavigation&lt;Configuration&gt;()\n</code></pre>"},{"location":"navigation/panels/navigation/#the-navigation-process","title":"The navigation process","text":"<p>During the navigation process, the <code>Child Panels</code> navigation model compares the new state with the previous one. It ensures that all removed components are destroyed, and all created components have correct lifecycle states</p> <p>The <code>Child Panels</code> navigation model usually performs the navigation synchronously, which means that by the time the <code>navigate</code> method returns, the navigation is finished and all component lifecycles are moved into required states. However, the navigation is performed asynchronously in case of recursive invocations - e.g. <code>navigate</code> is called from <code>onResume</code> lifecycle callback of a component being pushed. All recursive invocations are queued and performed one by one once the current navigation is finished.</p>"},{"location":"navigation/panels/navigation/#panelsnavigator-extension-functions","title":"PanelsNavigator extension functions","text":"<p>There are <code>PanelsNavigator</code> extension functions to simplify the navigation. Some of which were already used in the Child Panels Overview example.</p>"},{"location":"navigation/panels/navigation/#navigatemain-details-extra","title":"navigate(main, details, extra)","text":"<p>Sets the provided Main, Details and Extra configurations.</p> <p>Illustration 1</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.navigate(main = Main2, details = Details2, extra = Extra2)\n</code></pre> After<pre><code>{Main2, Details2, Extra2, SINGLE}\n</code></pre> <p>Illustration 2</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.navigate(main = Main2, details = null, extra = null)\n</code></pre> After<pre><code>{Main2, null, null, SINGLE}\n</code></pre>"},{"location":"navigation/panels/navigation/#navigatedetails-extra","title":"navigate(details, extra)","text":"<p>Sets the provided Details and Extra configurations.</p> <p>Illustration 1</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.navigate(details = Details2, extra = Extra2)\n</code></pre> After<pre><code>{Main1, Details2, Extra2, SINGLE}\n</code></pre> <p>Illustration 2</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.navigate(details = null, extra = null)\n</code></pre> After<pre><code>{Main1, null, null, SINGLE}\n</code></pre>"},{"location":"navigation/panels/navigation/#navigateextra","title":"navigate(extra)","text":"<p>Sets the provided Extra configuration.</p> <p>Illustration 2</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.navigate(extra = Extra2)\n</code></pre> After<pre><code>{Main1, Details1, Extra2, SINGLE}\n</code></pre> <p>Illustration 2</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.navigate(extra = null)\n</code></pre> After<pre><code>{Main1, Details1, null, SINGLE}\n</code></pre>"},{"location":"navigation/panels/navigation/#activatemainmain","title":"activateMain(main)","text":"<p>Activates the Main component represented by the specified <code>main</code> configuration, and dismisses (destroys) any currently active Main component.</p> <p>Illustration</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.activateMain(main = Main2)\n</code></pre> After<pre><code>{Main2, Details1, Extra1, SINGLE}\n</code></pre>"},{"location":"navigation/panels/navigation/#activatedetailsdetails","title":"activateDetails(details)","text":"<p>Activates the Details component represented by the specified <code>details</code> configuration, and dismisses (destroys) any currently active Details component.</p> <p>Illustration 1</p> Before<pre><code>{Main1, null, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.activateDetails(details = Details1)\n</code></pre> After<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <p>Illustration 2</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.activateDetails(details = Details2)\n</code></pre> After<pre><code>{Main1, Details2, Extra1, SINGLE}\n</code></pre>"},{"location":"navigation/panels/navigation/#dismissdetails","title":"dismissDetails()","text":"<p>Dismisses (destroys) the currently active Details component, if any.</p> <p>Illustration 1</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.dismissDetails()\n</code></pre> After<pre><code>{Main1, null, Extra1, SINGLE}\n</code></pre> <p>Illustration 2</p> Before<pre><code>{Main1, null, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.dismissDetails()\n</code></pre> After<pre><code>{Main1, null, Extra1, SINGLE}\n</code></pre>"},{"location":"navigation/panels/navigation/#activateextraextra","title":"activateExtra(extra)","text":"<p>Activates the Extra component represented by the specified <code>extra</code> configuration, and dismisses (destroys) any currently active Extra component.</p> <p>Illustration 1</p> Before<pre><code>{Main1, Details1, null, SINGLE}\n</code></pre> <pre><code>navigation.activateExtra(extra = Extra1)\n</code></pre> After<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <p>Illustration 2</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.activateExtra(extra = Extra2)\n</code></pre> After<pre><code>{Main1, Details1, Extra2, SINGLE}\n</code></pre>"},{"location":"navigation/panels/navigation/#dismissextra","title":"dismissExtra()","text":"<p>Dismisses (destroys) the currently active Extra component, if any.</p> <p>Illustration 1</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.dismissExtra()\n</code></pre> After<pre><code>{Main1, Details1, null, SINGLE}\n</code></pre> <p>Illustration 2</p> Before<pre><code>{Main1, Details1, null, SINGLE}\n</code></pre> <pre><code>navigation.dismissExtra()\n</code></pre> After<pre><code>{Main1, Details1, null, SINGLE}\n</code></pre>"},{"location":"navigation/panels/navigation/#pop","title":"pop()","text":"<p>Dismisses the Extra component (if it exists) or the Details component (if it exists).</p> <p>Illustration 1</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.pop()\n</code></pre> After<pre><code>{Main1, Details1, null, SINGLE}\n</code></pre> <p>Illustration 2</p> Before<pre><code>{Main1, Details1, null, SINGLE}\n</code></pre> <pre><code>navigation.pop()\n</code></pre> After<pre><code>{Main1, null, null, SINGLE}\n</code></pre> <p>Illustration 3</p> Before<pre><code>{Main1, null, null, SINGLE}\n</code></pre> <pre><code>navigation.pop()\n</code></pre> After<pre><code>{Main1, null, null, SINGLE}\n</code></pre>"},{"location":"navigation/panels/navigation/#setmodemode","title":"setMode(mode)","text":"<p>Sets <code>Panels.mode</code> to the specified <code>mode</code> value and updates component lifecycles accordingly.</p> <p>Illustration</p> Before<pre><code>{Main1, Details1, Extra1, SINGLE}\n</code></pre> <pre><code>navigation.setMode(ChildPanelsMode.DUAL)\n</code></pre> After<pre><code>{Main1, Details1, Extra1, DUAL}\n</code></pre>"},{"location":"navigation/panels/overview/","title":"Child Panels overview","text":""},{"location":"navigation/panels/overview/#the-child-panels","title":"The Child Panels","text":"<p><code>Child Panels</code> is a navigation model for managing a set of up to three child components (panels): Main (required), Details (optional) and Extra (optional). This navigation model can be compared with Compose List-Details Layout.</p> <p>Warning</p> <p>This navigation model is experimental since version <code>3.2.0-beta01</code>, the API is subject to change.</p> <p>Similarly to <code>Child Stack</code>, each component has its own <code>Lifecycle</code> automatically controlled by the navigation model depending on the current <code>ChildPanelsMode</code>.</p> <p>It is possible to have more than one <code>Child Panels</code> navigation model in a component, nested navigation is also supported.</p> <p>The <code>Child Panels</code> navigation model consists of the following main entities:</p> <ul> <li>Panels - represents a state of the <code>Child Panels</code> navigation model. The navigation is performed by creating a new navigation state from the previous one.<ul> <li><code>Panels#main</code> - a configuration of the Main panel.</li> <li><code>Panels#details</code> - an optional configuration of the Details panel, default value is <code>null</code>.</li> <li><code>Panels#extra</code> - an optional configuration of the Extra panel, default value is <code>null</code>.</li> <li><code>Panels#mode</code> - the current <code>ChildPanelsMode</code>, determines how lifecycles of the panels within the Child Panels navigation model are changing, default value is <code>ChildPanelsMode.SINGLE</code>.</li> </ul> </li> <li>ChildPanels - a simple data class that stores all child components (panels) and their configurations, as well as the current mode.<ul> <li><code>ChildPanels#main</code> - a Main child component.</li> <li><code>ChildPanels#details</code> - an optional Details child component.</li> <li><code>ChildPanels#extra</code> - an optional Extra child component.</li> <li><code>ChildPanels#mode</code> - the current <code>ChildPanelsMode</code>.</li> </ul> </li> <li>ChildPanelsMode - determines how lifecycles of the child components (panels) within the <code>Child Panels</code> navigation model are changing.</li> <li><code>SINGLE</code> - there is only one <code>RESUMED</code> panel at a time. If the Extra panel exists, then it is <code>RESUMED</code> and all other panels are <code>CREATED</code>. Otherwise, if the Details panel exists, then it is <code>RESUMED</code> and the Main panel is <code>CREATED</code>. Otherwise, the Main panel is <code>RESUMED</code>.</li> <li><code>DUAL</code> - there are at most two panels <code>RESUMED</code> at a time. The Main panel is always <code>RESUMED</code>. If the Extra panel exists, then it is <code>RESUMED</code> and the Details panel (if exists) is <code>CREATED</code>. Otherwise, if the Details panel exists, then it is <code>RESUMED</code>.</li> <li><code>TRIPLE</code> - any existing panel is always <code>RESUMED</code>.</li> <li>PanelsNavigation - an interface that accepts navigation commands and forwards them to all subscribed observers.</li> </ul>"},{"location":"navigation/panels/overview/#component-configurations","title":"Component Configurations","text":"<p>Similarly to <code>Child Stack</code>, each component created and managed by the <code>Child Panels</code> has a configuration, please read the documentation about child configurations.</p>"},{"location":"navigation/panels/overview/#initializing-child-panels","title":"Initializing Child Panels","text":"<p>There are three steps to initialize <code>Child Panels</code>:</p> <ul> <li>Create a new instance of <code>PanelsNavigation</code> and assign it to a variable or a property.</li> <li>Initialize the <code>Child Panels</code> navigation model using the <code>ComponentContext#childPanels</code> extension function and pass <code>PanelsNavigation</code> into it along with other arguments.</li> <li>The <code>childPanels</code> function returns <code>Value&lt;ChildPanels&gt;</code> that can be observed in the UI. Assign the returned <code>Value</code> to another property or a variable.</li> </ul>"},{"location":"navigation/panels/overview/#displaying-panels-with-compose","title":"Displaying panels with Compose","text":"<p><code>Child Panels</code> state can be observed and displayed in Compose by using the <code>ChildPanels</code> <code>Composable</code> function from the experimental Compose extensions module provided by Decompose. Please see the related documentation for more information.</p>"},{"location":"navigation/panels/overview/#example","title":"Example","text":"<p>Here is a very basic example of a list-details navigation:</p> Child components<pre><code>import com.arkivanov.decompose.ComponentContext\n\ninterface MainComponent\n\nclass DefaultMainComponent(\n    componentContext: ComponentContext,\n    onItemSelected: (id: Long) -&gt; Unit,\n) : MainComponent, ComponentContext by componentContext\n\ninterface DetailsComponent\n\nclass DefaultDetailsComponent(\n    componentContext: ComponentContext,\n    itemId: Long,\n    onFinished: () -&gt; Unit,\n) : DetailsComponent, ComponentContext by componentContext\n</code></pre> PanelsComponent<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.panels.ChildPanels\nimport com.arkivanov.decompose.router.panels.ChildPanelsMode\nimport com.arkivanov.decompose.router.panels.Panels\nimport com.arkivanov.decompose.router.panels.PanelsNavigation\nimport com.arkivanov.decompose.router.panels.activateDetails\nimport com.arkivanov.decompose.router.panels.childPanels\nimport com.arkivanov.decompose.router.panels.dismissDetails\nimport com.arkivanov.decompose.router.panels.setMode\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.builtins.serializer\n\ninterface PanelsComponent {\n\n    val panels: Value&lt;ChildPanels&lt;*, MainComponent, *, DetailsComponent, Nothing, Nothing&gt;&gt;\n\n    fun setMode(mode: ChildPanelsMode)\n}\n\nclass DefaultPanelsComponent(\n  componentContext: ComponentContext,\n) : PanelsComponent, ComponentContext by componentContext {\n\n    private val nav = PanelsNavigation&lt;Unit, DetailsConfig, Nothing&gt;()\n\n    override val panels: Value&lt;ChildPanels&lt;*, MainComponent, *, DetailsComponent, Nothing, Nothing&gt;&gt; =\n        childPanels(\n            source = nav,\n            serializers = Unit.serializer() to DetailsConfig.serializer(),\n            initialPanels = { Panels(main = Unit) },\n            handleBackButton = true,\n            mainFactory = { _, ctx -&gt;\n                DefaultMainComponent(\n                    componentContext = ctx,\n                    onItemSelected = { nav.activateDetails(details = DetailsConfig(itemId = it)) },\n                )\n            },\n            detailsFactory = { cfg, ctx -&gt;\n                DefaultDetailsComponent(\n                    componentContext = ctx,\n                    itemId = cfg.itemId,\n                    onFinished = nav::dismissDetails,\n                )\n            },\n        )\n\n    override fun setMode(mode: ChildPanelsMode) {\n         nav.setMode(mode)\n    }\n\n    @Serializable\n    private data class DetailsConfig(val itemId: Long)\n}\n</code></pre>"},{"location":"navigation/panels/overview/#screen-recreation-and-process-death-on-not-only-android","title":"Screen recreation and process death on (not only) Android","text":"<p><code>Child Panels</code> automatically preserves the state when a configuration change or process death occurs. To disable state preservation completely, pass <code>serializers = null</code> argument. When navigation state saving is disabled, the state is reset to the initial value when recreated.</p> <p>Components are created in their order. I.e. the Main component is created first, then the Details component is created (if exists), and lastly the Extra component is created (if exists). Components are destroyed in reverse order.</p>"},{"location":"navigation/panels/overview/#multiple-child-panels-in-a-component","title":"Multiple Child Panels in a component","text":"<p>When multiple <code>Child Panels</code> are used in one component, each such <code>Child Panels</code> must have a unique <code>key</code> argument associated. The keys are required to be unique only within the hosting component, so it is ok for different components to have <code>Child Panels</code> with same keys. An exception will be thrown if multiple <code>Child Panels</code> with the same key are detected in a component.</p>"},{"location":"navigation/slot/navigation/","title":"Navigation with Child Slot","text":""},{"location":"navigation/slot/navigation/#the-slotnavigator","title":"The SlotNavigator","text":"<p>All navigation in <code>Child Slot</code> is performed using the <code>SlotNavigator</code> interface, which is extended by the <code>SlotNavigation</code> interface. </p> <p><code>SlotNavigator</code> contains the <code>navigate</code> method with the following arguments:</p> <ul> <li><code>transformer</code> - converts the current configuration (if any) into a new one or <code>null</code>.</li> <li><code>onComplete</code> - called when navigation is finished.</li> </ul> <p>There is also <code>navigate</code> extension function without the <code>onComplete</code> callback, for convenience.</p> Creating the navigation<pre><code>// In your component class\nval navigation = SlotNavigation&lt;DialogConfig&gt;()\n</code></pre>"},{"location":"navigation/slot/navigation/#the-navigation-process","title":"The navigation process","text":"<p>During the navigation process, <code>Child Slot</code> compares the new configuration with the previous one. If both are the same, then no navigation is performed. Otherwise, the currently active component is destroyed (if any), and a new one is activated (if the new configuration is not <code>null</code>).  </p> <p><code>Child Slot</code> usually performs the navigation synchronously, which means that by the time the <code>navigate</code> method returns, the navigation is finished and all component lifecycles are moved into required states. However, the navigation is performed asynchronously in case of recursive invocations - e.g. <code>dismiss</code> is called from <code>onResume</code> lifecycle callback of a component being activated. All recursive invocations are queued and performed one by one once the current navigation is finished.</p>"},{"location":"navigation/slot/navigation/#slotnavigator-extension-functions","title":"SlotNavigator extension functions","text":"<p>There are <code>SlotNavigator</code> extension functions to simplify the navigation.</p>"},{"location":"navigation/slot/navigation/#activate","title":"activate","text":"<p>Activates a component with the provided <code>Configuration</code> (if not <code>null</code>). Any currently active component is destroyed.</p> <pre><code>navigation.activate(DialogConfig(title = \"Some title\"))\n</code></pre>"},{"location":"navigation/slot/navigation/#dismiss","title":"dismiss","text":"<p>Destroys the currently active component, if any.</p> <pre><code>navigation.dismiss()\n</code></pre>"},{"location":"navigation/slot/overview/","title":"Child Slot overview","text":""},{"location":"navigation/slot/overview/#the-child-slot","title":"The Child Slot","text":"<p><code>Child Slot</code> is a navigation model that allows only one child component at a time, or none. In other words, each <code>Child Slot</code> allows to activate a child component, replace with another child component, or dismiss when not needed. It is possible to have more than one <code>Child Slot</code> in a component, nested slots are also supported.</p> <p>The most common use cases include but not limited to displaying dialogs, drawers, bottom sheets, and just changing the visibility of some views. It's not necessarily something that overlays the parent component.</p> <p>The <code>Child Slot</code> navigation consists of two main entities:</p> <ul> <li>ChildSlot - a simple data class that holds the currently active child, if any.</li> <li>SlotNavigation - an interface that accepts navigation commands and forwards them to all subscribed observers.</li> </ul>"},{"location":"navigation/slot/overview/#component-configurations","title":"Component Configurations","text":"<p>Each component created and managed by the <code>Child Slot</code> has a configuration, please read the documentation about child configurations. </p>"},{"location":"navigation/slot/overview/#initializing-the-child-slot","title":"Initializing the Child Slot","text":"<p>There are three steps to initialize the <code>Child Slot</code>:</p> <ul> <li>Create a new instance of <code>SlotNavigation</code> and assign it to a variable or a property.</li> <li>Initialize the <code>Child Slot</code> using the <code>ComponentContext#childSlot</code> extension function and pass <code>SlotNavigation</code> into it along with other arguments.</li> <li>The <code>childSlot</code> function returns <code>Value&lt;ChildSlot&gt;</code> that can be observed in the UI. Assign the returned <code>Value</code> to another property or a variable.</li> </ul>"},{"location":"navigation/slot/overview/#example","title":"Example","text":"<p>Here is a very basic example of a child slot:</p> Dialog component<pre><code>import com.arkivanov.decompose.ComponentContext\n\ninterface DialogComponent {\n\n    fun onDismissClicked()\n}\n\nclass DefaultDialogComponent(\n    private val componentContext: ComponentContext,\n    private val message: String,\n    private val onDismissed: () -&gt; Unit,\n) : DialogComponent, ComponentContext by componentContext {\n\n    override fun onDismissClicked() {\n        onDismissed()\n    }\n}\n</code></pre> Root component<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.slot.ChildSlot\nimport com.arkivanov.decompose.router.slot.SlotNavigation\nimport com.arkivanov.decompose.router.slot.activate\nimport com.arkivanov.decompose.router.slot.childSlot\nimport com.arkivanov.decompose.router.slot.dismiss\nimport com.arkivanov.decompose.value.Value\nimport kotlinx.serialization.Serializable\n\ninterface RootComponent {\n\n    val dialog: Value&lt;ChildSlot&lt;*, DialogComponent&gt;&gt;\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    private val dialogNavigation = SlotNavigation&lt;DialogConfig&gt;()\n\n    override val dialog: Value&lt;ChildSlot&lt;*, DialogComponent&gt;&gt; =\n        childSlot(\n            source = dialogNavigation,\n            serializer = DialogConfig.serializer(), // Or null to disable navigation state saving\n            handleBackButton = true, // Close the dialog on back button press\n        ) { config, childComponentContext -&gt;\n            DefaultDialogComponent(\n                componentContext = childComponentContext,\n                message = config.message,\n                onDismissed = dialogNavigation::dismiss,\n            )\n        }\n\n    private fun showDialog(message: String) {\n        dialogNavigation.activate(DialogConfig(message = message))\n    }\n\n    @Serializable // kotlinx-serialization plugin must be applied\n    private data class DialogConfig(\n        val message: String,\n    )\n}\n</code></pre>"},{"location":"navigation/slot/overview/#multiple-child-slots-in-a-component","title":"Multiple Child Slots in a component","text":"<p>When multiple <code>Child Slots</code> are used in one component, each such <code>Child Slot</code> must have a unique key associated. The keys are required to be unique only within the parent (hosting) component, so it is ok for different components to have <code>Child Slots</code> with same keys. An exception will be thrown if multiple <code>Child Slots</code> with the same key are detected in a component.</p> Two Child Slots in one component<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.slot.SlotNavigation\nimport com.arkivanov.decompose.router.slot.childSlot\n\nclass Root(\n    componentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n    private val topNavigation = SlotNavigation&lt;TopConfig&gt;()\n\n    private val topSlot =\n        childSlot&lt;TopConfig, TopChild&gt;(\n            source = topNavigation,\n            key = \"TopSlot\",\n            // Omitted code\n        )\n\n    private val bottomNavigation = SlotNavigation&lt;BottomConfig&gt;()\n\n    private val bottomSlot =\n        childSlot&lt;BottomConfig, BottomChild&gt;(\n            source = bottomNavigation,\n            key = \"BottomSlot\",\n            // Omitted code\n        )\n}\n</code></pre>"},{"location":"navigation/stack/browser-history/","title":"Web Browser History","text":"<p>Warning</p> <p>This API is likely to be removed in the future. Please see the successor of this experimental API: Web Navigation API.</p> <p>By default <code>Child Stack</code> navigation does not affect URLs in the browser address bar. But sometimes it is necessary to have different URLs for different <code>Child Stack</code> destinations. For this purpose Decompose provides an experimental API - WebHistoryController.</p> <p>The controller listens for the <code>Child Stack</code> state changes and updates the browser URL and the history accordingly:</p> <ul> <li>When one or more components are pushed to the <code>Child Stack</code> stack, the controller pushes corresponding pages to the history</li> <li>When one or more components are popped from the stack, the controller pops corresponding pages from the history</li> <li>When some components are replaced in the stack, the controller tries its best to keep the page history aligned (there are corner cases)</li> <li>When the user presses the browser's Back button (or selects one of the previous pages in the history dropdown menu), the controller pops the corresponding configurations from the <code>Child Stack</code></li> <li>When the user navigates forward in the browser history, the controller pushes the corresponding configurations to the <code>Child Stack</code></li> </ul>"},{"location":"navigation/stack/browser-history/#corner-cases","title":"Corner cases","text":"<p>There is one known corner case due to the History API limitations. When all configurations in the stack are replaced with another single configuration (<code>A</code>&lt;-<code>B</code>&lt;-<code>C</code> ===&gt; <code>D</code>), the pages corresponding to the second and subsequent removed configurations (<code>B</code> and <code>C</code>) remain in the history. If at this point the user will move forward (by clicking on the Forward button in the browser), the previously removed configurations will be pushed back to the stack (the stack will become <code>D</code>&lt;-<code>B</code> or <code>D</code>&lt;-<code>B</code>&lt;-<code>C</code>).</p>"},{"location":"navigation/stack/browser-history/#limitations","title":"Limitations","text":"<p>Only one <code>Child Stack</code> can be attached to an instance of the <code>WebHistoryController</code>. Having multiple instances of the controller is not allowed.</p>"},{"location":"navigation/stack/browser-history/#configuring-the-application","title":"Configuring the application","text":"<p>Using <code>WebHistoryController</code> in a single page application requires additional configuration - a catch-all strategy to return the same html resource for all paths. This strategy will be different for different server configurations.</p>"},{"location":"navigation/stack/browser-history/#development-configuration","title":"Development configuration","text":"<p>The Kotlin/JS <code>browser</code> target uses webpack-dev-server as a local development server. It can be configured to use the same <code>index.html</code> file (or your primary html file) for all paths, by setting the devServer.historyApiFallback flag. The Gradle DSL for Kotlin webpack currently does not support the <code>historyApiFallback</code> flag, so a special configuration file should be used instead.</p> <p>First, create a directory named <code>webpack.config.d</code> in the JS app module's directory. Then create a new file named <code>devServerConfig.js</code> inside that directory. Finally, put the following content to the file:</p> <pre><code>// &lt;js app module&gt;/webpack.config.d/devServerConfig.js\n\nconfig.devServer = {\n  ...config.devServer, // Merge with other devServer settings\n  \"historyApiFallback\": true\n};\n</code></pre>"},{"location":"navigation/stack/browser-history/#using-the-webhistorycontroller","title":"Using the WebHistoryController","text":"<p>Using <code>WebHistoryController</code> is easy:</p> <ol> <li>Create an instance of <code>DefaultWebHistoryController</code> in the JS app and pass it via constructor to a component responsible for navigation (typically it is the root component).</li> <li>Create <code>Child Stack</code> and use <code>WebHistoryController#historyPaths</code> property for initial stack. This is required for cases when the page is reloaded (refreshed), so that the stack is aligned with te browser history.</li> <li>In the component, call the <code>WebHistoryController.attach</code> method and supply all arguments.</li> <li>In the JS app, pass an initial deeplink to the component.</li> <li>Use the deeplink in the component to generate an initial back stack.</li> </ol>"},{"location":"navigation/stack/deeplinking/","title":"Deep linking","text":"<p>Users following links on devices have one goal in mind: to get to the content they want to see. Decompose provides ability to override initial destinations and back stack. A typical approach is to parse deep links on the platform side and then pass the initial destination data to the root component and then down the tree to all the required components.</p> <p>Parsing deep links on the platform side is beyond this documentation. This information should be available in the platform's specific documentation. For example here is the related documentation for Android.</p>"},{"location":"navigation/stack/deeplinking/#handling-deep-links","title":"Handling deep links","text":"<p>Given the basic example from the Child Stack Overview page, we can easily handle deep links. Let's say we have a link like <code>http://myitems.com?itemId=3</code>. When the user clicks on it, we want to open the details screen of the item with the provided <code>id</code>. When the user closes the details screen, they should be navigated back to the list screen. The idea is to pass parsed data from the deep link to a component responsible for navigation, in our case it is the <code>Root</code> component.</p> <pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport kotlinx.serialization.Serializable\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n    initialItemId: Long? = null, // It can be any other type, e.g. a sealed class with all possible destinations\n) : RootComponent, ComponentContext by componentContext {\n\n    private val navigation = StackNavigation&lt;Config&gt;()\n\n    private val stack =\n        childStack(\n            source = navigation,\n            initialStack = {\n                listOfNotNull(\n                    Config.List,\n                    if (initialItemId != null) Config.Details(itemId = initialItemId) else null,\n                )\n            },\n            handleBackButton = true,\n            childFactory = ::createChild,\n        )\n\n    // Omitted code\n\n    @Serializable\n    private sealed class Config {\n        @Serializable\n        data object List : Config()\n\n        @Serializable\n        data class Details(val itemId: Long) : Config()\n    }\n}\n</code></pre> <p>Now, if the <code>initialItemId</code> is supplied, the initial screen will be the <code>ItemDetails</code> component. The <code>ItemList</code> component will be in the back stack, so the user will be able to go back.</p>"},{"location":"navigation/stack/deeplinking/#handling-deep-links-on-android","title":"Handling deep links on Android","text":"<p>The first step is to configure your Android app so that it can handle deep links. Please follow the official documentation.</p> <p>Warning</p> <p>It is strongly recommended to always use the <code>standard</code> (default) launchMode for <code>Activity</code> when handling deep links.</p> <p>Once the app is configured, the deeplink <code>Intent</code> will be available to use in <code>Activity#onCreate</code> method. The <code>handleDeepLink</code> extension function can be used to automatically extract the deep link <code>Uri</code> from the <code>Intent</code>, it also takes care of restarting the <code>Activity</code> task and finishing the current <code>Activity</code> if needed (similarly to how it works with the official Jetpack navigation).</p> <pre><code>import android.content.Intent\nimport android.net.Uri\nimport android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.defaultComponentContext\nimport com.arkivanov.decompose.handleDeepLink\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val root = \n            handleDeepLink { uri -&gt;\n                val initialItemId = uri?.extractInitialItemId()\n                DefaultRootComponent(\n                    componentContext = defaultComponentContext(\n                        discardSavedState = initialItemId != null, // Discard any saved state if there is a deep link\n                    ),\n                    initialItemId = initialItemId,\n                )\n            } ?: return\n\n        setContent {\n            // Omitted code\n        }\n    }\n\n    private fun Uri.extractInitialItemId(): Long = TODO(\"Extract the initial item id from the deep link\")\n}\n</code></pre>"},{"location":"navigation/stack/deeplinking/#alternative-way","title":"Alternative way","text":"<p>The alternative way can be used if for some reason you don't want to use the <code>standard</code> (default) launchMode for the <code>Activity</code>, and instead of restarting the root component you prefer handling the new deep link manually in <code>Activity#onNewIntent</code>.</p> <pre><code>import android.content.Intent\nimport android.net.Uri\nimport android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.defaultComponentContext\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var root: RootComponent\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val initialItemId = intent.data?.extractInitialItemId()\n\n        root =\n            DefaultRootComponent(\n                componentContext = defaultComponentContext(),\n                initialItemId = initialItemId,\n            )\n\n        setContent {\n            // Omitted code\n        }\n    }\n\n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n\n        val initialItemId = intent.data?.extractInitialItemId() ?: return\n        root.onDeepLink(initialItemId)\n    }\n\n    private fun Uri.extractInitialItemId(): Long? =\n        TODO(\"Extract the initial item id from the deep link\")\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n    initialItemId: Long? = null,\n) : RootComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    fun onDeepLink(initialItemId: Long) {\n        navigation.replaceAll(Config.List, Config.Details(itemId = initialItemId))\n    }\n\n    // Omitted code\n}\n</code></pre>"},{"location":"navigation/stack/navigation/","title":"Navigation with Child Stack","text":""},{"location":"navigation/stack/navigation/#the-stacknavigator","title":"The StackNavigator","text":"<p>All navigation in <code>Child Stack</code> is performed using the <code>StackNavigator</code> interface, which is extended by the <code>StackNavigation</code> interface.</p> <p><code>StackNavigator</code> contains the <code>navigate</code> method with the following arguments:</p> <ul> <li><code>transformer</code> - converts the current stack of configurations to a new one. The stack is represented as <code>List</code>, where the last element is the top of the stack, and the first element is the bottom of the stack.</li> <li><code>onComplete</code> - called when navigation is finished.</li> </ul> <p>There is also <code>navigate</code> extension function without the <code>onComplete</code> callback, for convenience.</p> <p>Warning</p> <p>The configuration stack returned by the <code>transformer</code> function must not be empty.</p> Creating the navigation<pre><code>// In your component class\nval navigation = StackNavigation&lt;Configuration&gt;()\n</code></pre>"},{"location":"navigation/stack/navigation/#the-navigation-process","title":"The navigation process","text":"<p>During the navigation process, the <code>Child Stack</code> navigation model compares the new stack of configurations with the previous one. It ensures that all removed components are destroyed, and that there is only one component resumed at a time - the top one. All components in the back stack are always either stopped or destroyed.</p> <p>The <code>Child Stack</code> navigation model usually performs the navigation synchronously, which means that by the time the <code>navigate</code> method returns, the navigation is finished and all component lifecycles are moved into required states. However, the navigation is performed asynchronously in case of recursive invocations - e.g. <code>pop</code> is called from <code>onResume</code> lifecycle callback of a component being pushed. All recursive invocations are queued and performed one by one once the current navigation is finished.</p>"},{"location":"navigation/stack/navigation/#stacknavigator-extension-functions","title":"StackNavigator extension functions","text":"<p>There are <code>StackNavigator</code> extension functions to simplify the navigation. Some of which were already used in the Child Stack Overview example.</p>"},{"location":"navigation/stack/navigation/#pushconfiguration","title":"push(configuration)","text":"<p>Pushes the provided <code>Configuration</code> at the top of the stack. Decompose will throw an exception if the provided <code>Configuration</code> is already present in the stack. This usually happens when a component is pushed on user interaction (e.g. a button click). Consider using pushNew instead.</p> <p>Illustration</p> Before<pre><code>[A, B*]\n</code></pre> <pre><code>navigation.push(Configuration.C)\n</code></pre> After<pre><code>[A, B, C*]\n</code></pre>"},{"location":"navigation/stack/navigation/#pushnewconfiguration","title":"pushNew(configuration)","text":"<p>Pushes the provided <code>Configuration</code> at the top of the stack. Does nothing if the provided <code>Configuration</code> is already on top of the stack. Decompose will throw an exception if the provided <code>Configuration</code> is already present in the back stack (not at the top of the stack).</p> <p>This can be useful when pushing a component on button click, to avoid pushing the same component if the user clicks the same button quickly multiple times.</p> <p>Illustration 1</p> Before<pre><code>[A, B*]\n</code></pre> <pre><code>navigation.pushNew(Configuration.C)\n</code></pre> After<pre><code>[A, B, C*]\n</code></pre> <p>Illustration 2</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.pushNew(Configuration.C)\n</code></pre> After<pre><code>[A, B, C*]\n</code></pre>"},{"location":"navigation/stack/navigation/#pushtofrontconfiguration","title":"pushToFront(configuration)","text":"<p>Pushes the provided configuration to the top of the stack, removing the configuration from the back stack, if any.</p> <p>This API works similar to <code>bringToFront</code>, except it compares configurations by equality rather than by configuration class.</p> <p>Illustration 1</p> Before<pre><code>[A(1), B(1)*]\n</code></pre> <pre><code>navigation.pushToFront(Configuration.A(2))\n</code></pre> After<pre><code>[A(1), B(1), A(2)*]\n</code></pre> <p>Illustration 2</p> Before<pre><code>[A(1), B(1), A(2)]\n</code></pre> <pre><code>navigation.pushToFront(Configuration.A(1))\n</code></pre> After<pre><code>[B(1), A(2), A(1)*]\n</code></pre> <p>Illustration 3</p> Before<pre><code>[A(1), B(1), A(2)]\n</code></pre> <pre><code>navigation.pushToFront(Configuration.A(2))\n</code></pre> After<pre><code>[A(1), B(1), A(2)*]\n</code></pre>"},{"location":"navigation/stack/navigation/#pop","title":"pop","text":"<p>Pops the latest configuration at the top of the stack.</p> <p>Illustration</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.pop()\n\n// Or\n\nnavigation.pop { isSuccess -&gt;\n    // Called when the navigation is finished.\n    // isSuccess - `true` if the stack size was greater than 1 and a component was popped, `false` otherwise.\n}\n</code></pre> After<pre><code>[A, B*]\n</code></pre>"},{"location":"navigation/stack/navigation/#popwhilepredicate","title":"popWhile(predicate)","text":"<p>Pops configurations at the top of the stack while the provided predicate returns true.</p> <p>Illustration</p> Before<pre><code>[A, B, C, D*]\n</code></pre> <pre><code>navigation.popWhile { topOfStack: Configuration -&gt; topOfStack !is B }\n</code></pre> After<pre><code>[A, B*]\n</code></pre>"},{"location":"navigation/stack/navigation/#poptoindex","title":"popTo(index)","text":"<p>Pops configurations at the top of the stack so that the provided index becomes active (the new top of the stack).</p> <p>Illustration</p> Before<pre><code>[A, B, C, D*]\n</code></pre> <pre><code>navigation.popTo(index = 1)\n</code></pre> After<pre><code>[A, B*]\n</code></pre>"},{"location":"navigation/stack/navigation/#poptofirst","title":"popToFirst","text":"<p>Pops configurations at the top of the stack so that the first configuration becomes active (the new top of the stack).</p> <p>Illustration</p> Before<pre><code>[A, B, C, D*]\n</code></pre> <pre><code>navigation.popToFirst()\n</code></pre> After<pre><code>[A*]\n</code></pre>"},{"location":"navigation/stack/navigation/#replacecurrentconfiguration","title":"replaceCurrent(configuration)","text":"<p>Replaces the current configuration at the top of the stack with the provided <code>Configuration</code>.</p> <p>Illustration</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.replaceCurrent(Configuration.D)\n</code></pre> After<pre><code>[A, B, D*]\n</code></pre>"},{"location":"navigation/stack/navigation/#replaceallvararg-configurations","title":"replaceAll(vararg configurations)","text":"<p>Replaces all configurations currently in the stack with the provided configurations. Components that remain in the stack are not recreated, components that are no longer in the stack are destroyed.</p> <p>Illustration</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.replaceAll(Configuration.B, Configuration.C, Configuration.D)\n</code></pre> After<pre><code>[B, C, D*]\n</code></pre>"},{"location":"navigation/stack/navigation/#bringtofrontconfiguration","title":"bringToFront(configuration)","text":"<p>Removes all components with configurations of the provided <code>Configuration</code>'s class, and adds the provided <code>Configuration</code> to the top of the stack. This is primarily helpful when implementing a Decompose app with Bottom Navigation. See the related discussion in the old repository.</p> <p>Note</p> <p>The operation is performed as one transaction. If there is already a component with the same configuration, it will not be recreated.</p> <p>Illustration</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.bringToFront(Configuration.B)\n</code></pre> After<pre><code>[A, C, B*]\n</code></pre>"},{"location":"navigation/stack/overview/","title":"Child Stack overview","text":""},{"location":"navigation/stack/overview/#the-child-stack","title":"The Child Stack","text":"<p><code>Child Stack</code> is a navigation model for managing a stack of components, just like <code>FragmentManager</code>.</p> <p>Each component has its own <code>Lifecycle</code>. Each time a new component is pushed to the stack, the currently active component is stopped. When a component is popped from the stack, the previous component is resumed. This allows business logic to run while the component is in the back stack. It is possible to have more than one <code>Child Stack</code> in a component, nested stacks are also supported.</p> <p>The <code>Child Stack</code> navigation consists of two main entities:</p> <ul> <li>ChildStack - a simple data class that stores a stack of components and their configurations.<ul> <li>ChildStack#active - contains the currently active component.</li> <li>ChildStack#backStack - contains the back stack of inactive components.</li> </ul> </li> <li>StackNavigation - an interface that accepts navigation commands and forwards them to all subscribed observers.</li> </ul>"},{"location":"navigation/stack/overview/#component-configurations","title":"Component Configurations","text":"<p>Each component created and managed by the <code>Child Stack</code> has a configuration, please read the documentation about child configurations.</p> <p><code>Child Stack</code> adds one additional requirement for child configurations:</p> <ul> <li>Configurations must be unique (by equality) within the <code>Child Stack</code>.</li> </ul>"},{"location":"navigation/stack/overview/#the-experimental-duplicate-configurations-mode","title":"The experimental Duplicate Configurations mode","text":"<p>You can also try enabling the experimental Duplicate Configurations mode using the following flag:</p> <pre><code>DecomposeExperimentFlags.duplicateConfigurationsEnabled = true\n</code></pre> <p>This will allow having duplicate configurations in all navigation models. Please keep in mind that this feature is experimental.</p>"},{"location":"navigation/stack/overview/#initializing-the-child-stack","title":"Initializing the Child Stack","text":"<p>There are three steps to initialize the <code>Child Stack</code>:</p> <ul> <li>Create a new instance of <code>StackNavigation</code> and assign it to a variable or a property.</li> <li>Initialize the <code>Child Stack</code> using the <code>ComponentContext#childStack</code> extension function and pass <code>StackNavigation</code> into it along with other arguments.</li> <li>The <code>childStack</code> function returns <code>Value&lt;ChildStack&gt;</code> that can be observed in the UI. Assign the returned <code>Value</code> to another property or a variable.</li> </ul>"},{"location":"navigation/stack/overview/#displaying-the-stack-with-compose","title":"Displaying the stack with Compose","text":"<p><code>Child Stack</code> state can be observed and displayed in Compose by using the <code>Children</code> <code>Composable</code> function from the Compose extensions module provided by Decompose. Please see the related documentation for more information.</p>"},{"location":"navigation/stack/overview/#example","title":"Example","text":"<p>Here is a very basic example of navigation between two child components:</p> ItemList component<pre><code>import com.arkivanov.decompose.ComponentContext\n\ninterface ItemListComponent {\n\n    // Omitted code\n\n    fun onItemClicked(id: Long)\n}\n\nclass DefaultItemListComponent(\n    componentContext: ComponentContext,\n    private val onItemSelected: (id: Long) -&gt; Unit\n) : ItemListComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    override fun onItemClicked(id: Long) {\n        onItemSelected(id)\n    }\n}\n</code></pre> ItemDetails component<pre><code>import com.arkivanov.decompose.ComponentContext\n\ninterface ItemDetailsComponent {\n\n    // Omitted code\n\n    fun onCloseClicked()\n}\n\nclass DefaultItemDetailsComponent(\n    componentContext: ComponentContext,\n    itemId: Long,\n    private val onFinished: () -&gt; Unit\n) : ItemDetailsComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    override fun onCloseClicked() {\n        onFinished()\n    }\n}\n</code></pre> Root component<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport com.arkivanov.decompose.router.stack.pop\nimport com.arkivanov.decompose.router.stack.push\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.sample.shared.RootComponent.Child.DetailsChild\nimport com.arkivanov.sample.shared.RootComponent.Child.ListChild\nimport kotlinx.serialization.Serializable\n\ninterface RootComponent {\n\n    val childStack: Value&lt;ChildStack&lt;*, Child&gt;&gt;\n\n    sealed class Child {\n        class ListChild(val component: ItemListComponent) : Child()\n        class DetailsChild(val component: ItemDetailsComponent) : Child()\n    }\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    private val navigation = StackNavigation&lt;Config&gt;()\n\n    override val childStack: Value&lt;ChildStack&lt;*, RootComponent.Child&gt;&gt; =\n        childStack(\n            source = navigation,\n            serializer = Config.serializer(), // Or null to disable navigation state saving \n            initialConfiguration = Config.List,\n            handleBackButton = true, // Pop the back stack on back button press\n            childFactory = ::createChild,\n        )\n\n    private fun createChild(config: Config, componentContext: ComponentContext): RootComponent.Child =\n        when (config) {\n            is Config.List -&gt; ListChild(itemList(componentContext))\n            is Config.Details -&gt; DetailsChild(itemDetails(componentContext, config))\n        }\n\n    private fun itemList(componentContext: ComponentContext): ItemListComponent =\n        DefaultItemListComponent(\n            componentContext = componentContext,\n            onItemSelected = { navigation.push(Config.Details(itemId = it)) }\n        )\n\n    private fun itemDetails(componentContext: ComponentContext, config: Config.Details): ItemDetailsComponent =\n        DefaultItemDetailsComponent(\n            componentContext = componentContext,\n            itemId = config.itemId,\n            onFinished = { navigation.pop() }\n        )\n\n    @Serializable // kotlinx-serialization plugin must be applied\n    private sealed class Config {\n        @Serializable\n        data object List : Config()\n\n        @Serializable\n        data class Details(val itemId: Long) : Config()\n    }\n}\n</code></pre>"},{"location":"navigation/stack/overview/#components-in-the-back-stack","title":"Components in the back stack","text":"<p><code>Child Stack</code> can not be empty, there is always one active (resumed) child component. Components in the back stack are always stopped. When <code>Child Stack</code> is first initialized or recreated after e.g. process death, all components are automatically created and the active component is resumed.</p>"},{"location":"navigation/stack/overview/#screen-recreation-and-process-death-on-not-only-android","title":"Screen recreation and process death on (not only) Android","text":"<p><code>Child Stack</code> automatically preserves the state when a configuration change or process death occurs. To disable state preservation completely, pass <code>serializer = null</code> argument. When navigation state saving is disabled, the state is reset to the initial value when recreated.</p> <p>Components are created in their order. E.g. the first component in the back stack is created first, then the next component in the back stack is created, and so on. The active component is the latest component created.</p> <p>Components are destroyed in reverse order, e.g. the active component is destroyed first, then the last component in the back stack is destroyed, and so on.</p>"},{"location":"navigation/stack/overview/#delivering-a-result-when-navigating-back","title":"Delivering a result when navigating back","text":"<p>To deliver a result from one component to another:</p> <ul> <li>Pass a callback to the <code>second</code> component.</li> <li>Call the callback with a <code>result</code> from the <code>second</code> component.</li> <li>In the <code>parent</code> component, supply the callback when instantiating the <code>second</code> component.</li> <li>When the callback is invoked, perform the navigation, e.g. by using <code>navigation.pop { ... }</code>.</li> <li>After the navigation is performed, call a method on the <code>first</code> component with the <code>result</code>.</li> </ul> Child components<pre><code>interface ItemListComponent {\n\n    fun onItemClicked(id: Long)\n\n    fun onItemDeleted(id: Long)\n}\n\nclass DefaultItemListComponent(\n    componentContext: ComponentContext,\n    private val onItemSelected: (id: Long) -&gt; Unit,\n) : ItemListComponent, ComponentContext by componentContext {\n\n    override fun onItemClicked(id: Long) {\n        onItemSelected(id)\n    }\n\n    override fun onItemDeleted(id: Long) {\n        // TODO: Handle item deleted\n    }\n}\n\ninterface ItemDetailsComponent {\n\n    fun onDeleteClicked()\n}\n\nclass DefaultItemDetailsComponent(\n    componentContext: ComponentContext,\n    private val itemId: Long,\n    private val onDeleted: (itemId: Long) -&gt; Unit\n) : ItemDetailsComponent, ComponentContext by componentContext {\n\n    override fun onDeleteClicked() {\n        // TODO: Delete the item\n        onDeleted(itemId)\n    }\n}\n</code></pre> Root component<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.pop\nimport com.arkivanov.decompose.router.stack.push\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    private fun itemList(componentContext: ComponentContext): ItemListComponent =\n        DefaultItemListComponent(\n            componentContext = componentContext,\n            onItemSelected = { navigation.push(Config.Details(itemId = it)) }\n        )\n\n    private fun itemDetails(componentContext: ComponentContext, config: Config.Details): ItemDetailsComponent =\n        DefaultItemDetailsComponent(\n            componentContext = componentContext,\n            itemId = config.itemId,\n            onDeleted = { itemId -&gt;\n                navigation.pop { // Pop ItemDetailsComponent\n                    // Deliver the result to ItemList component\n                    (stack.active.instance as? ListChild)?.component?.onItemDeleted(id = itemId)\n                }\n            }\n        )\n\n    // Omitted code\n}\n</code></pre>"},{"location":"navigation/stack/overview/#alternative-way","title":"Alternative way","text":"<p>It is also possible to deliver results using reactive streams - e.g. coroutines <code>Flow</code> or Rx <code>Observable</code>.</p> <p>Here is an example using Reaktive library. Kotlin coroutines <code>SharedFlow</code> should be very similar.</p> <pre><code>interface ItemListComponent {\n\n    fun onItemClicked(id: Long)\n\n    sealed interface Input {\n        class ItemDeleted(val id: Long) : Input\n    }\n}\n\ninterface ItemDetailsComponent {\n\n    fun onDeleteClicked()\n}\n\n// Helper factory function creating DisposableScope attached to the Lifecycle.\n// Creating CoroutineScope is very similar.\nfun LifecycleOwner.disposableScope(): DisposableScope {\n    val scope = DisposableScope()\n    lifecycle.doOnDestroy(scope::dispose)\n    return scope\n}\n\nclass DefaultItemListComponent(\n    componentContext: ComponentContext,\n    input: Observable&lt;ItemList.Input&gt;,\n    private val onItemSelected: (id: Long) -&gt; Unit,\n) : ItemListComponent, ComponentContext by componentContext, DisposableScope by componentContext.disposableScope() {\n\n    init {\n        // Subscribe to input\n        input.subscribeScoped {\n            when (it) {\n                is ItemList.Input.ItemDeleted -&gt; TODO(\"Handle item deleted\")\n            }\n        }\n    }\n\n    override fun onItemClicked(id: Long) {\n        onItemSelected(id)\n    }\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    // Omitted code\n\n    // Or MutableSharedFlow&lt;ItemList.Input&gt;(extraBufferCapacity = Int.MAX_VALUE)\n    private val listInput = PublishSubject&lt;ItemList.Input&gt;()\n\n    private fun itemList(componentContext: ComponentContext): DefaultItemListComponent =\n        DefaultItemListComponent(\n            componentContext = componentContext,\n            input = listInput, // Pass listInput to ItemListComponent\n            onItemSelected = { navigation.push(Config.Details(itemId = it)) },\n        )\n\n    private fun itemDetails(componentContext: ComponentContext, config: Config.Details): ItemDetailsComponent =\n        DefaultItemDetailsComponent(\n            componentContext = componentContext,\n            itemId = config.itemId,\n            onItemDeleted = { id -&gt;\n                navigation.pop { // Pop ItemDetailsComponent\n                    // Deliver the result to ItemList component\n                    listInput.onNext(ItemList.Input.ItemDeleted(id = id))\n                }\n            },\n        )\n\n    // Omitted code\n}\n</code></pre>"},{"location":"navigation/stack/overview/#multiple-child-stacks-in-a-component","title":"Multiple Child Stacks in a component","text":"<p>When multiple <code>Child Stacks</code> are used in one component, each such <code>Child Stack</code> must have a unique key associated. The keys are required to be unique only within the parent (hosting) component, so it is ok for different components to have <code>Child Stacks</code> with same keys. An exception will be thrown if multiple <code>Child Stacks</code> with the same key are detected in a component.</p> Two Child Stacks in one component<pre><code>class DefaultRootComponent(\n    componentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n    private val topNavigation = StackNavigation&lt;TopConfig&gt;()\n\n    private val topStack =\n        childStack&lt;TopConfig, TopChild&gt;(\n            source = topNavigation,\n            key = \"TopStack\",\n            // Omitted code\n        )\n\n    private val bottomNavigation = StackNavigation&lt;BottomConfig&gt;()\n\n    private val bottomStack =\n        childStack&lt;BottomConfig, BottomChild&gt;(\n            source = bottomNavigation,\n            key = \"BottomStack\",\n            // Omitted code\n        )\n}\n</code></pre>"},{"location":"tips-tricks/composable-viewmodel/","title":"Calling Composable functions with ViewModels","text":"<p>This section may be useful when migrating from the official navigation-compose library to Decompose.</p> <p>By default, Decompose doesn't manage AndroidX ViewModel. When Decompose is used as root in an Activity or Fragment then by default all <code>ViewModels</code> are scoped to that Activity/Fragment. In other words, by default Decompose doesn't create separate <code>ViewModelStoreOwner</code> for every child screen.</p> <p>If there is a requirement to call a <code>Composable</code> function that uses a <code>ViewModel</code> (e.g. there is a <code>Composable</code> screen that can't be migrated to Decompose), then we need to create a separate <code>ViewModelStoreOwner</code> for every child screen manually.</p> <p>Consider there is a stack of Main and Details screens. The Main screen is a normal Decompose component.</p> Main component<pre><code>import com.arkivanov.decompose.ComponentContext\n\ninterface MainComponent {\n    fun onShowDetailsClicked()\n}\n\nclass DefaultMainComponent(\n    componentContext: ComponentContext,\n    private val onShowDetails: () -&gt; Unit\n) : MainComponent, ComponentContext by componentContext {\n    // Omitted code\n}\n</code></pre> <p>The Details screen is a <code>Composable</code> function with a <code>ViewModel</code>, e.g. an existing screen that is difficult to migrate to Decompose.</p> Details screen<pre><code>import androidx.compose.runtime.Composable\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewmodel.compose.viewModel\n\n@Composable\nfun DetailsContent(viewModel: DetailsViewModel = viewModel()) {\n    // Omitted code\n}\n\nclass DetailsViewModel : ViewModel() { \n    // Omitted code\n}\n</code></pre>"},{"location":"tips-tricks/composable-viewmodel/#injecting-a-viewmodel-into-a-composable-function","title":"Injecting a ViewModel into a Composable function","text":"<p>Decompose destroys components as soon as they are removed from the hierarchy (e.g. when a screen is popped from the stack). This may cause issues when injecting <code>ViewModels</code> into <code>Composable</code> functions. If the removed screen is still animating but its <code>ViewModel</code> has already been cleared, a new instance of the <code>ViewModel</code> may be created on next re-composition, causing a memory leak.</p> <p>To prevent the issue described above, <code>ViewModel</code> injecting should be done in a special way.</p> ViewModel injecting function<pre><code>import androidx.compose.runtime.Composable\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewmodel.compose.viewModel\n\n@Composable\ninline fun &lt;reified T : ViewModel&gt; rememberViewModel(): T {\n    var vm by remember { mutableStateOf&lt;T?&gt;(null) }\n    if (vm == null) {\n        vm = viewModel&lt;T&gt;()\n    }\n\n    return requireNotNull(vm)\n}\n</code></pre> <p>Then just replace all usages of the <code>viewModel()</code> injecting function with the new <code>rememberViewModel()</code> function.</p> Details screen<pre><code>import androidx.compose.runtime.Composable\nimport androidx.lifecycle.ViewModel\n\n@Composable\nfun DetailsContent(viewModel: DetailsViewModel = rememberViewModel()) {\n    // Omitted code\n}\n\nclass DetailsViewModel : ViewModel() { \n    // Omitted code\n}\n</code></pre>"},{"location":"tips-tricks/composable-viewmodel/#composable-functions-with-viewmodels-without-savedstatehandle","title":"Composable functions with ViewModels WITHOUT SavedStateHandle","text":"<p>The fix is very simple when <code>SavedStateHandle</code> is not required.</p> <p>First, we need an extension function to attach <code>ViewModelStore</code> to <code>InstanceKeeper</code> of a child component.</p> Attaching ViewModelStore to InstanceKeeper<pre><code>import androidx.lifecycle.ViewModelStore\nimport androidx.lifecycle.ViewModelStoreOwner\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeperOwner\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\n\ninternal fun InstanceKeeperOwner.viewModelStoreOwner(): ViewModelStoreOwner =\n    instanceKeeper.getOrCreate(::ViewModelStoreOwnerInstance)\n\nprivate class ViewModelStoreOwnerInstance : ViewModelStoreOwner, InstanceKeeper.Instance {\n    override val viewModelStore: ViewModelStore = ViewModelStore()\n\n    override fun onDestroy() {\n        viewModelStore.clear()\n    }\n}\n</code></pre> <p>Now we need to expose a <code>ViewModelStoreOwner</code> instead of the child component.</p> Root component<pre><code>import androidx.lifecycle.ViewModelStoreOwner\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport com.arkivanov.decompose.router.stack.pushNew\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.sample.app.RootComponent.Child\nimport com.arkivanov.sample.app.RootComponent.Child.ListChild\nimport com.arkivanov.sample.app.RootComponent.Child.MainChild\nimport kotlinx.serialization.Serializable\n\ninterface RootComponent {\n\n    val childStack: Value&lt;ChildStack&lt;*, Child&gt;&gt;\n\n    sealed class Child {\n        class ListChild(val component: MainComponent) : Child()\n        class MainChild(val component: ViewModelStoreOwner) : Child() // ViewModelStoreOwner instead of component\n    }\n}\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    private val nav = StackNavigation&lt;Config&gt;()\n\n    override val childStack: Value&lt;ChildStack&lt;*, Child&gt;&gt; =\n        childStack(\n            source = nav,\n            serializer = Config.serializer(),\n            initialConfiguration = Config.Main,\n        ) { config, ctx -&gt;\n            when (config) {\n                is Config.Main -&gt;\n                    ListChild(\n                        component = DefaultMainComponent(\n                            componentContext = ctx,\n                            onShowDetails = { nav.pushNew(Config.Details) },\n                        ),\n                    )\n\n                is Config.Details -&gt;\n                    MainChild(\n                        component = ctx.viewModelStoreOwner(), // Attach a ViewModelStore to the child InstanceKeeper\n                    )\n            }\n        }\n\n    @Serializable\n    private sealed interface Config {\n        @Serializable\n        data object Main : Config\n\n        @Serializable\n        data object Details : Config\n    }\n}\n</code></pre> <p>Not we just have to provide the child <code>ViewModelStoreOwner</code> via <code>LocalViewModelStoreOwner</code> provider.</p> <pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.CompositionLocalProvider\nimport androidx.lifecycle.viewmodel.compose.LocalViewModelStoreOwner\nimport com.arkivanov.decompose.extensions.compose.stack.Children\nimport com.arkivanov.sample.app.RootComponent.Child.MainChild\nimport com.arkivanov.sample.app.RootComponent.Child.ListChild\n\n@Composable\nfun RootContent(component: RootComponent) {\n    Children(stack = component.childStack) { (_, child) -&gt;\n        when (child) {\n            is ListChild -&gt; MainContent(child.component)\n\n            is MainChild -&gt;\n                CompositionLocalProvider(LocalViewModelStoreOwner provides child.component) {\n                    DetailsContent() // The Details screen now has its own ViewModelStore\n                }\n        }\n    }\n}\n</code></pre>"},{"location":"tips-tricks/composable-viewmodel/#composable-functions-with-viewmodels-with-savedstatehandle","title":"Composable functions with ViewModels WITH SavedStateHandle","text":"<p>Things are a bit more complicated when injecting <code>SavedStateHandle</code> is required.</p> <p>Since on Android the state saving works via <code>Bundle</code>, we'll need to create a serializer for it.</p> BundleSerializer<pre><code>import android.os.Bundle\nimport android.os.Parcel\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.builtins.ByteArraySerializer\nimport kotlinx.serialization.descriptors.SerialDescriptor\nimport kotlinx.serialization.encoding.Decoder\nimport kotlinx.serialization.encoding.Encoder\n\ninternal object BundleSerializer : KSerializer&lt;Bundle&gt; {\n    private val byteArraySerializer = ByteArraySerializer()\n    override val descriptor: SerialDescriptor = byteArraySerializer.descriptor\n\n    override fun serialize(encoder: Encoder, value: Bundle) {\n        encoder.encodeSerializableValue(byteArraySerializer, value.toByteArray())\n    }\n\n    private fun Bundle.toByteArray(): ByteArray {\n        val parcel = Parcel.obtain()\n        try {\n            parcel.writeBundle(this)\n            return parcel.marshall()\n        } finally {\n            parcel.recycle()\n        }\n    }\n\n    override fun deserialize(decoder: Decoder): Bundle =\n        decoder.decodeSerializableValue(byteArraySerializer).toBundle()\n\n    private fun ByteArray.toBundle(): Bundle {\n        val parcel = Parcel.obtain()\n        try {\n            parcel.unmarshall(this, 0, size)\n            parcel.setDataPosition(0)\n            return requireNotNull(parcel.readBundle())\n        } finally {\n            parcel.recycle()\n        }\n    }\n}\n</code></pre> <p>Now we need a special reusable <code>ViewModelStoreComponent</code> that will implement <code>ViewModelStoreOwner</code> interface, and also manage argument passing and state saving for <code>ViewModels</code>.</p> ViewModelStoreComponent<pre><code>import android.os.Bundle\nimport androidx.lifecycle.HasDefaultViewModelProviderFactory\nimport androidx.lifecycle.Lifecycle\nimport androidx.lifecycle.LifecycleRegistry\nimport androidx.lifecycle.SavedStateViewModelFactory\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.ViewModelStoreOwner\nimport androidx.savedstate.SavedStateRegistry\nimport androidx.savedstate.SavedStateRegistryController\nimport androidx.savedstate.SavedStateRegistryOwner\nimport com.arkivanov.decompose.ComponentContext\n\nclass ViewModelStoreComponent(\n    ctx: ComponentContext,\n    args: Bundle = Bundle(),\n) : ViewModelStoreOwner by ctx.viewModelStoreOwner(),\n    SavedStateRegistryOwner,\n    HasDefaultViewModelProviderFactory {\n\n    private val savedStateRegistryController = SavedStateRegistryController.create(this)\n    override val savedStateRegistry: SavedStateRegistry get() = savedStateRegistryController.savedStateRegistry\n    override val lifecycle: Lifecycle = LifecycleRegistry(provider = this)\n\n    override val defaultViewModelProviderFactory: ViewModelProvider.Factory =\n        SavedStateViewModelFactory(application = null, owner = this, defaultArgs = args)\n\n    init {\n        savedStateRegistryController.performRestore(ctx.stateKeeper.consume(KEY_SAVED_STATE, BundleSerializer))\n\n        ctx.stateKeeper.register(KEY_SAVED_STATE, BundleSerializer) {\n            Bundle().also(savedStateRegistryController::performSave)\n        }\n    }\n\n    private companion object {\n        private const val KEY_SAVED_STATE = \"saved_state\"\n    }\n}\n</code></pre> <p>Finally, we can use <code>ViewModelStoreComponent</code> in the Root component as follows.</p> Using ViewModelStoreComponent<pre><code>import androidx.core.os.bundleOf\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport com.arkivanov.decompose.router.stack.pushNew\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.sample.app.RootComponent.Child\nimport com.arkivanov.sample.app.RootComponent.Child.ListChild\nimport com.arkivanov.sample.app.RootComponent.Child.MainChild\nimport kotlinx.serialization.Serializable\n\nclass DefaultRootComponent(\n    componentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\n    private val nav = StackNavigation&lt;Config&gt;()\n\n    override val childStack: Value&lt;ChildStack&lt;*, Child&gt;&gt; =\n        childStack(\n            source = nav,\n            serializer = Config.serializer(),\n            initialConfiguration = Config.Main,\n        ) { config, ctx -&gt;\n            when (config) {\n                is Config.Main -&gt;\n                    ListChild(\n                        component = DefaultMainComponent(\n                            componentContext = ctx,\n                            onShowDetails = { text -&gt;\n                                nav.pushNew(Config.Details(text = text)) // Pass text to the Details screen\n                            },\n                        ),\n                    )\n\n                is Config.Details -&gt;\n                    MainChild(\n                        component = ViewModelStoreComponent( // Pass ViewModelStoreComponent as ViewModelStoreOwner\n                            ctx = ctx,\n                            args = bundleOf(\n                                \"text\" to config.text, // Pass arguments to DetailsViewModel\n                            )\n                        ),\n                    )\n            }\n        }\n\n    @Serializable\n    private sealed interface Config {\n        @Serializable\n        data object Main : Config\n\n        @Serializable\n        data class Details(val text: String) : Config\n    }\n}\n</code></pre> <p>Now we are able to inject <code>SavedStateHandle</code> into <code>DetailsViewModel</code>.</p> Using SavedStateHandle<pre><code>import androidx.lifecycle.SavedStateHandle\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewmodel.compose.viewModel\n\nclass ItemDetailsViewModel(savedStateHandle: SavedStateHandle) : ViewModel() {\n    val text: String = checkNotNull(savedStateHandle[\"text\"])\n}\n</code></pre>"},{"location":"tips-tricks/composable-viewmodel/#composable-functions-with-viewmodels-using-jetpackcomponentcontext","title":"Composable functions with ViewModels using JetpackComponentContext","text":"<p>The new JetpackComponentContext makes it easy to call Composable functions with ViewModels, regardless of whether <code>SavedStateHandle</code> is needed or not. The code from the above snippets can be simplified, i.e. <code>BundleSerializer</code> and <code>ViewModelStoreComponent</code> are no longer needed in this case.</p> <pre><code>import androidx.lifecycle.DEFAULT_ARGS_KEY\nimport androidx.savedstate.savedState\nimport com.arkivanov.decompose.ExperimentalDecomposeApi\nimport com.arkivanov.decompose.jetpackcomponentcontext.JetpackComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.router.stack.StackNavigation\nimport com.arkivanov.decompose.router.stack.childStack\nimport com.arkivanov.decompose.router.stack.pushNew\nimport com.arkivanov.decompose.value.Value\nimport com.arkivanov.sample.app.RootComponent.Child\nimport com.arkivanov.sample.app.RootComponent.Child.ListChild\nimport com.arkivanov.sample.app.RootComponent.Child.MainChild\nimport kotlinx.serialization.Serializable\n\n@OptIn(ExperimentalDecomposeApi::class)\nclass DefaultRootComponent(\n    componentContext: JetpackComponentContext, // Pass JetpackComponentContext instead of ComponentContext\n) : RootComponent, JetpackComponentContext by componentContext {\n\n    private val nav = StackNavigation&lt;Config&gt;()\n\n    override val childStack: Value&lt;ChildStack&lt;*, Child&gt;&gt; =\n        childStack(\n            source = nav,\n            serializer = Config.serializer(),\n            initialConfiguration = Config.Main,\n        ) { config, ctx -&gt;\n            when (config) {\n                is Config.Main -&gt; ListChild(...) // Same as above\n\n                is Config.Details -&gt;\n                    MainChild(\n                        component = ctx.apply {\n                            defaultViewModelCreationExtras[DEFAULT_ARGS_KEY] =\n                                savedState {\n                                    putString(\"text\", config.text) // Pass arguments to DetailsViewModel\n                                }\n                        },\n                    )\n            }\n        }\n\n    @Serializable\n    private sealed interface Config { ... }\n}\n</code></pre>"},{"location":"tips-tricks/navigation-compose-component/","title":"Hosting a component in navigation-compose","text":"<p>This section may be useful when migrating from the official navigation-compose library to Decompose. We can convert screens to Decompose gradually (one by one), keeping the navigation untouched until every screen is converted. This section describes how we can host a Decompose component (or a tree of components) in a <code>Composable</code> screen managed by <code>navigation-compose</code> library.</p> <p>Note</p> <p>This section implies minimum Decompose version <code>3.0.0-alpha06</code>.</p> <p>Warning</p> <p>The <code>navigation-compose</code> library provides only two scopes for a screen: the <code>Composable</code> function of the scren and the <code>ViewModel</code> scope. There is no such a scope that is also destroyed on configuration change. So the only scope where we can host Decompose components is the <code>ViewModel</code> scope. This means we should take extra care to not leak any objects - don't pass <code>NavController</code> (or any other objects with a narrower scope), don't pass lamdas or callbacks capturing those objects, etc.</p> <p>Here is a function that allows hosting a Decompose component in a <code>navigation-compose</code> screen.</p> <pre><code>import android.os.Bundle\nimport androidx.activity.OnBackPressedCallback\nimport androidx.activity.compose.LocalOnBackPressedDispatcherOwner\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.DisposableEffect\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.lifecycle.DefaultLifecycleObserver\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.createSavedStateHandle\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.ComponentContextFactory\nimport com.arkivanov.decompose.DefaultComponentContext\nimport com.arkivanov.essenty.backhandler.BackDispatcher\nimport com.arkivanov.essenty.backhandler.connectOnBackPressedCallback\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeperDispatcher\nimport com.arkivanov.essenty.lifecycle.LifecycleRegistry\nimport com.arkivanov.essenty.lifecycle.create\nimport com.arkivanov.essenty.lifecycle.destroy\nimport com.arkivanov.essenty.lifecycle.pause\nimport com.arkivanov.essenty.lifecycle.resume\nimport com.arkivanov.essenty.lifecycle.start\nimport com.arkivanov.essenty.lifecycle.stop\nimport com.arkivanov.essenty.statekeeper.SerializableContainer\nimport com.arkivanov.essenty.statekeeper.StateKeeperDispatcher\nimport com.arkivanov.essenty.statekeeper.getSerializableContainer\nimport com.arkivanov.essenty.statekeeper.putSerializableContainer\n\n@Composable\nfun &lt;T&gt; rememberRetainedComponent(key: String = \"ComposableComponent\", factory: (ComponentContext) -&gt; T): T {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    val lifecycle = lifecycleOwner.lifecycle\n    val onBackPressedDispatcher = LocalOnBackPressedDispatcherOwner.current?.onBackPressedDispatcher\n\n    val holder =\n        viewModel {\n            val handle = createSavedStateHandle()\n            val ctx = RetainedComponentContext(handle.get&lt;Bundle&gt;(key)?.getSerializableContainer(key))\n            handle.setSavedStateProvider(key) { Bundle().apply { putSerializableContainer(key, ctx.stateKeeper.save()) } }\n            Holder(factory(ctx), ctx)\n        }\n\n    DisposableEffect(lifecycle) {\n        val observer = LifecycleAdapter(holder.componentContext.lifecycle)\n        lifecycle.addObserver(observer)\n        onDispose { lifecycle.removeObserver(observer) }\n    }\n\n    if (onBackPressedDispatcher != null) {\n        DisposableEffect(lifecycleOwner, onBackPressedDispatcher) {\n            val onBackPressedCallback = holder.componentContext.onBackPressedCallback\n            onBackPressedDispatcher.addCallback(lifecycleOwner, onBackPressedCallback)\n            onDispose(onBackPressedCallback::remove)\n        }\n    }\n\n    return holder.instance\n}\n\nprivate class LifecycleAdapter(\n    private val lifecycle: LifecycleRegistry\n) : DefaultLifecycleObserver {\n    override fun onCreate(owner: LifecycleOwner) {\n        lifecycle.create()\n    }\n\n    override fun onStart(owner: LifecycleOwner) {\n        lifecycle.start()\n    }\n\n    override fun onResume(owner: LifecycleOwner) {\n        lifecycle.resume()\n    }\n\n    override fun onPause(owner: LifecycleOwner) {\n        lifecycle.pause()\n    }\n\n    override fun onStop(owner: LifecycleOwner) {\n        lifecycle.stop()\n    }\n}\n\nprivate class RetainedComponentContext(savedState: SerializableContainer?) : ComponentContext {\n    override val lifecycle: LifecycleRegistry = LifecycleRegistry()\n    override val stateKeeper: StateKeeperDispatcher = StateKeeperDispatcher(savedState)\n    override val instanceKeeper: InstanceKeeperDispatcher = InstanceKeeperDispatcher()\n    override val backHandler: BackDispatcher = BackDispatcher()\n    val onBackPressedCallback: OnBackPressedCallback = backHandler.connectOnBackPressedCallback()\n\n    override val componentContextFactory: ComponentContextFactory&lt;ComponentContext&gt; =\n        ComponentContextFactory(::DefaultComponentContext)\n}\n\nprivate class Holder&lt;out T&gt;(\n    val instance: T,\n    val componentContext: RetainedComponentContext,\n) : ViewModel(componentContext.lifecycle::destroy, componentContext.instanceKeeper::destroy)\n</code></pre> <p>Here is the usage example.</p> <pre><code>import androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.Button\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.navigation.compose.rememberNavController\nimport com.arkivanov.decompose.ComponentContext\n\n@Composable\nfun App() {\n    val nav = rememberNavController()\n\n    NavHost(navController = nav, startDestination = \"home\") {\n        composable(\"home\") {\n            HomeScreen(onShowDetails = { nav.navigate(\"details\") })\n        }\n\n        composable(\"details\") {\n            val detailsComponent = rememberRetainedComponent(factory = ::DetailsComponent)\n            DetailsComponent(component = detailsComponent, onBack = nav::popBackStack)\n        }\n    }\n}\n\n@Composable\nfun HomeScreen(onShowDetails: () -&gt; Unit) {\n    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n        Button(onClick = onShowDetails) {\n            Text(\"Go to details\")\n        }\n    }\n}\n\nclass DetailsComponent(\n    componentContext: ComponentContext,\n) : ComponentContext by componentContext {\n    // Some code here\n}\n\n@Composable\nfun DetailsComponent(component: DetailsComponent, onBack: () -&gt; Unit) {\n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center,\n    ) {\n        Button(onClick = onBack) {\n            Text(\"Go back\")\n        }\n    }\n}\n</code></pre>"},{"location":"tips-tricks/overview/","title":"Tips and Tricks","text":"<p>This section contains various hints, tips and tricks that can be useful when using Decompose.</p> <ul> <li>Calling Composable functions with ViewModels</li> <li>Hosting a component in navigation-compose</li> </ul>"}]}